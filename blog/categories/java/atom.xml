<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | mike、mikeなるままに…]]></title>
  <link href="http://mike-neck.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mike-neck.github.io/"/>
  <updated>2014-06-13T14:23:57+09:00</updated>
  <id>http://mike-neck.github.io/</id>
  <author>
    <name><![CDATA[mike-neck]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GradleでHerokuのアプリを作ってみる]]></title>
    <link href="http://mike-neck.github.io/blog/2014/06/11/gradledeherokufalseapuriwozuo-tutemiru/"/>
    <updated>2014-06-11T17:51:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2014/06/11/gradledeherokufalseapuriwozuo-tutemiru</id>
    <content type="html"><![CDATA[<p><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRb2JjNjFTYUhILTQ" style="width : 400px;"/></p>

<p>久々にブログ書いています。</p>

<p>こんにちわ、みけです。</p>

<p>昨年の7月〜8月頃から、家をでるのが困難になり、</p>

<p>かつ何の活動をするのも億劫になっていたため、</p>

<p>ブログすらまともに書いていませんでした。</p>

<h2>GradleでHerokuにアプリケーションをデプロイする</h2>

<p><strong>Gradle Heroku</strong>で検索をするとGradleで作ったアプリケーションを</p>

<p>Herokuにデプロイする方法が出てきます。</p>

<p>ただ、まあ、なんというか、みんなJetty embbededを使って<code>static void main</code>から</p>

<p>始まるアプリケーションが多かったので、</p>

<p>jetty-runnerでwarファイルを走らせる方法をここではまとめてあります。</p>

<p>…</p>

<p>もう既にJava好きな皆さんにとっては、なんというかもう常識的なことなので、</p>

<p>ここに書いてあることは当たり前なのかもしれませんが…</p>

<p>以下、必要なファイル毎に書いていきます。</p>

<ul>
<li>build.gradle</li>
<li>Procfile</li>
<li>system.properties</li>
</ul>


<h2>build.gradle</h2>

<p>Herokuでjetty-runnerでwebアプリを動かす場合に注意する点は次のとおりです</p>

<h3><code>gradle wrapper</code>を実行しておく</h3>

<p>実行する<code>gradle</code>のバージョンを一致させるために</p>

<p><code>gradle wrapper</code>を実行しておきます。</p>

<p><code>
$ gradle wrapper
</code></p>

<p>これで、プロジェクトのディレクトリーに<code>gradlew</code>が作成されていることを確認しておきます。</p>

<h3><code>jetty</code>プラグインを使う</h3>

<p>これは別に<code>war</code>プラグインでも構いませんが、</p>

<p>ローカルで動かしてテストしたいだろうと思いますので、</p>

<p><code>jetty</code>プラグインを使います。</p>

<p><code>groovy build.gradle
apply plugin : 'jetty'
</code></p>

<h3><code>providedCompile</code> configurationで<code>jetty-runner</code>を指定する</h3>

<p><code>jetty-runner</code>でHerokuアプリを走らせますので、</p>

<p><code>providedCompile</code> configurationで<code>jetty-runner</code>を指定しておきます。</p>

<p>```groovy build.gradle
repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'javax.servlet:javax.servlet-api:3.1.0'
providedCompile ('org.eclipse.jetty:jetty-runner:9.2.0.v20140526') {
    exclude module : 'javax.servlet-api'
}
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
```</p>

<hr />

<p>また、<code>jetty-runner</code>をディレクトリー指定してダウンロードさせるために、</p>

<p><code>Copy</code>タイプのタスクを作成します。</p>

<p>```groovy build.gradle
task copyJetty (type : Copy) {</p>

<pre><code>into "$buildDir/jetty"
from configurations.providedCompile
</code></pre>

<p>}
```</p>

<h3><code>stage</code>タスクを用意する</h3>

<p>HerokuでのGradleアプリケーションは<code>stage</code>タスクにてアプリケーションのビルドをします。</p>

<p>そのため、<code>stage</code>タスクに実行させておきたいタスクを記述しておきます。</p>

<p><code>groovy build.gradle
task stage (dependsOn : ['clean', 'copyJetty'])
stage.finalizedBy build
</code></p>

<p>上記で作成した<code>copyJetty</code>タスクは何故かファイルを上書きしてしまったので、</p>

<p>task finalizationで最終的に<code>build</code>タスクを実行させます。</p>

<p>これらをまとめた<code>build.gradle</code>は次のとおり</p>

<p>```groovy build.gradle
apply plugin : &lsquo;jetty&rsquo;
repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'javax.servlet:javax.servlet-api:3.1.0'
providedCompile ('org.eclipse.jetty:jetty-runner:9.2.0.v20140526') {
    exclude module : 'javax.servlet-api'
}
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
task copyJetty (type : Copy) {</p>

<pre><code>into "$buildDir/jetty"
from configurations.providedCompile
</code></pre>

<p>}
task stage (dependsOn : [&lsquo;clean&rsquo;, &lsquo;copyJetty&rsquo;])
stage.finalizedBy build
```</p>

<h2>Procfile</h2>

<p><code>Procfile</code>にはアプリケーション実行のコマンドを記述しておきます。(あまりよくわかってない…)</p>

<p>最初、僕はこのファイルでgradleの<code>jettyRunWar</code>を実行させようとしていたのですが、</p>

<p>見事にコケてました。</p>

<p><code>bash Procfile
web: java $JAVA_OPTS -jar build/jetty/jetty-runner-9.2.0.v20140526.jar --port $PORT build/libs/*.war
</code></p>

<p>またHerokuのgradlewで作成されるwarファイルも、</p>

<p>なんかランダムな文字列になっているので、</p>

<p>warファイル指定にワイルドカードを使っています。</p>

<h2>system.properties</h2>

<p>ここにはJavaのバージョンを指定します。</p>

<p>僕はJava8を使いたかったのでjava8を指定します。</p>

<p><code>java system.properties
java.runtime.version=1.7
</code></p>

<h2>Herokuへのアプリケーションのデプロイ</h2>

<p>Herokuへのデプロイは皆さんが御存知の通りで、</p>

<p>僕が説明するまでのことはないでしょう。</p>

<ul>
<li>toolbeltをインストールする</li>
<li>Herokuアカウントを作成する</li>
<li>Herokuにssh-keyを登録する</li>
<li>heroku側にアプリケーションを作成する</li>
<li>herokuにpushする</li>
</ul>


<p>heroku側にアプリケーションを作成するために、次のコマンドを打ちます</p>

<p><code>bash command-line
$ heroku create
</code></p>

<p>herokuにpushするために次のコマンドを打ちます</p>

<p><code>bash command-line
$ git push heroku master
</code></p>

<p>これでアプリケーションのデプロイが完了します。</p>

<p>{% render_partial _includes/post/post_footer.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaFXをヘッドレスブラウザーとして使うための基本テク #javafx]]></title>
    <link href="http://mike-neck.github.io/blog/2013/07/02/one-of-techniques-to-use-javafx-as-headless-browser/"/>
    <updated>2013-07-02T10:28:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/07/02/one-of-techniques-to-use-javafx-as-headless-browser</id>
    <content type="html"><![CDATA[<p>こんにちわ、みけです。</p>

<p>JavaFXをヘッドレスブラウザーとして使おうとして、</p>

<p>いろいろとWebのリダイレクトにハマりまくっています。</p>

<p>で、今回はJavaFXをJavaFXのスレッド以外のスレッドから扱うTipsを集めました。</p>

<h2>Goal</h2>

<h4>期待していいこと</h4>

<ul>
<li>JavaFXの操作をJavaFXの外からする方法</li>
</ul>


<h4>期待してはいけないこと</h4>

<ul>
<li>GUIプログラミングの云々かんぬん</li>
</ul>


<h2>Basics</h2>

<p>JavaFXのアプリケーションのサンプル的な起動方法は次のとおりです。</p>

<p>```java SampleApplication.java
import javafx.application.Application;
import javafx.stage.Stage;
// この中のmainメソッドからアプリケーションを起動しちゃう
public class SampleApplication extends Application {</p>

<pre><code>public static void main(String... args) {
    Application.launch(SampleApplication.class);
}
@Override
public void start(Stage stage) throws Exception {
    // do something.
}
</code></pre>

<p>}
```</p>

<p>さて、この方法を採用している限りにおいては、</p>

<p>JavaFXのスレッドがどうのこうのでハマることはありません。</p>

<p>今回のテーマはJavaFXアプリケーションの外と内をわけることにあります。</p>

<p>JavaFXアプリケーションはバックグラウンドで実行します。</p>

<p>そのためには<code>java.util.concurrent.ExecutorService</code>を用います。</p>

<p>```java ApplicationLauncher.java
import javafx.application.Application;
import javafx.application.Platform;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
// 先ほどのSampleApplicationを起動します。
public class ApplicationLauncher {</p>

<pre><code>private static final ExecutorService SERVICE =
        Executors.newFixedThreadPool(1);
public static void main(String... args) {
    // launch application
    SERVICE.submit(new Runnable(){
        @Override
        public void run() {
            Application.launch(SampleApplication.class);
        }
    });
    // do something
    // shutdown application
    Platform.exit();
    SERVICE.shutdown();
}
</code></pre>

<p>}
```</p>

<h2><code>Platform#RunLater(java.lang.Runnable)</code></h2>

<p>JavaFX上でのみ動作するオブジェクトへの操作は<code>Platform#runLater(java.lang.Runnable)</code>を</p>

<p>通じて行います。</p>

<p>```java ControllerStimulation.java
import javafx.application.Platform;
public class ControllerStimulation {</p>

<pre><code>// JavaFXのcontrollerクラスのインスタンス
private SampleController controller;
// Platform#runLater(Runnable)を通じてcontrollerクラスへの操作を行う。
public void simulateClickButton () {
    Platform.runLater(new SimulateClickButton());
}
// 実際にcontrollerクラスを操作するRunnable
private class SimulateClickButton implements Runnable {
    @Override
    public void run () {
        controller.clickButton(null);
    }
}
</code></pre>

<p>}
```</p>

<h2>戻り値を利用したい場合</h2>

<p>御存知の通り、<code>java.lang.Runnable#run()</code>は値を返しませんので、</p>

<p>値の受け渡しには<code>java.util.concurrent.BlockingQueue&lt;T&gt;</code>を使うことになります。</p>

<p><code>Platform#runLater</code>が<code>java.util.concurrent.Callable&lt;T&gt;</code>を引数にとって、</p>

<p><code>java.util.concurrent.Future&lt;T&gt;</code>を返してくれるといいんですけどね…</p>

<p>```java JavascriptExecution.java
import javafx.application.Platform;
import javafx.scene.web.WebEngine;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
public class JavascriptExecution {</p>

<pre><code>// controllerクラスのインスタンス
private SampleController controller;
public String callJavascript(String javascript) {
    final BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();
    Platform.runLater(new CallJavascript(queue, javascript));
    try {
        String result = queue.take();
        return result;
    } catch(InterruptedException e) {
        throw new RuntimeException(e);
    }
}
private class CallJavascript implements Runnable {
    private final BlockingQueue&lt;String&gt; queue;
    private final String script;
    CallJavascript(final BlockingQueue&lt;String&gt; queue, String script) {
        this.queue = queue;
        this.script = script;
    }
    @Override
    public void run() {
        WebEngine engine = controller.getEngine();
        String result = (String) engine.executeScript(script);
        try {
            queue.put(result);
        } catch(InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
</code></pre>

<p>}
```</p>

<p>実際はJavascriptなどでエラーがあると、<code>netscape.javascript.JSException</code>がthrowされるので、</p>

<p><code>Platform#runLater(java.lang.Runnable)</code>で<code>java.lang.RuntimeException</code>を検知して、</p>

<p>Applicatoinを終了させるような仕組みを組み込んでおくことが望まれるのですが、</p>

<p>それはここでの話を逸脱するし、誰得な気がするので、</p>

<p>やめておく…</p>

<p>以下、実際に僕が書いているコード</p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRQVYweDh2QU1LVk0" target="_blank"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRQVYweDh2QU1LVk0" style="width : 450px;"></a></p>

<p>{% render_partial _includes/post/post_footer.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaFXをheadless browserとして使うためのJSObjectの扱い方 - 1]]></title>
    <link href="http://mike-neck.github.io/blog/2013/07/01/using-javafx-as-headless-browser/"/>
    <updated>2013-07-01T13:03:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/07/01/using-javafx-as-headless-browser</id>
    <content type="html"><![CDATA[<p>こんにちわ。</p>

<p>みけです。</p>

<p>JavaFXでjavascriptのテスティングフレームワークを作ろうと思ってから、</p>

<p>早1年半。</p>

<p>全然成果があがっていません。</p>

<p>今日は、そんな自分のための俺得なエントリー。</p>

<p><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRbkltQVpjMUkzNE0" style="width : 450px;"/></p>

<h2>Goal</h2>

<h4>期待していいこと</h4>

<ul>
<li>JSObjectでのarrayの取り扱い</li>
</ul>


<h4>期待できないこと</h4>

<ul>
<li>JavaFXのスレッドの同期方法</li>
<li>JSObjectでのobjectの取り扱い</li>
</ul>


<h2>JSObjectの扱い方 &ndash; array編</h2>

<p><code>JSObject#getSlot(int)</code>を使ってarrayの要素を取得します。</p>

<p>```java
final String script = &ldquo;(function(){return [&lsquo;a&rsquo;, 2, &lsquo;c&rsquo;, 4, &lsquo;e&rsquo;];})()&rdquo;;
final BlockingQueue<JSObject> queue = new LinkedBlockingQueue&lt;>();
Platform.runLater(() &ndash;> {</p>

<pre><code>queue.put((JSObject) webEngine.executeScript(script));
</code></pre>

<p>});
JSObject array = queue.take();
for (int i = 0; i &lt; 5; i++) {</p>

<pre><code>System.out.println(i + " -&gt; " + array.getSlot(i));
</code></pre>

<p>}
```</p>

<p>結果は次のようになります。</p>

<p><code>
0 -&gt; a
1 -&gt; 2
2 -&gt; c
3 -&gt; 4
4 -&gt; e
</code></p>

<p>ちなみに要素のindexより多い数を<code>JSObject#getSLot(int)</code>の引数に渡すと、</p>

<p><code>String</code>の<code>undefined</code>が返ってきます。</p>

<p>{% render_partial _includes/post/post_footer.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一回渋谷javaに行ってきた]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/30/first-shibuya-java/"/>
    <updated>2013-06-30T15:05:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/30/first-shibuya-java</id>
    <content type="html"><![CDATA[<p><a href="http://atnd.org/events/40140">第一回渋谷java</a>というのに行って来ました。</p>

<p>javaの勉強会としては比較的若い人の集まった勉強会だったと思います。</p>

<hr />

<p>自己紹介で「好きなEclipseのショートカットは？」とか聞かれたので、</p>

<p>相変わらずのことで「Eclipse氏ね」と答えて来ました。</p>

<p>後、Eclipseの代替するエディターがvimだったので、</p>

<p>いや、IntelliJ IDEAですからとも自己紹介しておきました。</p>

<hr />

<p>一応タイトルはネタっぽいですが、</p>

<p>真面目な話をして来ました。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/23694003" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>


<hr />

<p>他の参加者のブログがいくつかあるようです。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/jflute/20130629/1372519117">新たなるJavaの風景、渋谷javaがスタート！</a></li>
<li><a href="http://blog.k11i.biz/2013/06/java.html">第１回 #渋谷Java でトークしてきました</a></li>
<li><a href="http://hotchemi.hateblo.jp/entry/2013/06/29/230427">第1回渋谷Javaに行ってきた</a></li>
</ul>


<p>あと、いくつかスライドがアップロードされています。</p>

<p>JavaとOSS &ndash; ユーザーサイドから語ってみる</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/23660334" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/commonplace0807/java-23660334" title="渋谷Java第一回" target="_blank">渋谷Java第一回</a> </strong> from <strong><a href="http://www.slideshare.net/commonplace0807" target="_blank">commonplace0807</a></strong> </div></p>

<hr />

<p>今回は初回ということでLTだけでしたが、ハンズオンなども実施していくとのことです。</p>

<p>Eclipse強制されるのでなければ、行こうかなと思います。</p>

<p>{% render_partial _includes/post/post_footer.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java8 lambda式を使ってみた]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/27/java8-lambdashi-woshi-tutemita/"/>
    <updated>2013-06-27T22:24:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/27/java8-lambdashi-woshi-tutemita</id>
    <content type="html"><![CDATA[<p>こんにちわ、みけです。</p>

<p>Java8初心者勉強会というのを開催してみました。</p>

<p>参加者2人でした。</p>

<p>Java8はだれも興味ないんだなと思いました。</p>

<h2>Java8のラムダ式</h2>

<p>特にもうこれといって目新しいこともありません。</p>

<p>メソッドが一つだけのインターフェースを記述するときに、</p>

<p>非常に記述が楽になるというものです。</p>

<p>例えば次のようなクラスがあるとします。</p>

<p>```java Item.jara
public class Item {</p>

<pre><code>final String name;
final int price;
public Item(String name, int price) {
    this.name = name;
    this.price = price;
}
public String getName() {
    return name;
}
public int getPrice() {
    return price;
}
</code></pre>

<p>}
```</p>

<p>上記の<code>Item</code>クラスを<code>price</code>の昇順、<code>name</code>の昇順でソートするコードは以下のようになります。</p>

<p>```java
List<Item> items = getItemList();
items.sort((left, right) &ndash;> {</p>

<pre><code>int priceOrder = left.getPrice() - right.getPrice();
int nameOrder = left.getName().
        compareTo(right.getNmae());
return priceOrder != 0? priceOrder : nameOrder;
</code></pre>

<p>});
```</p>

<p>ところで、<code>Item</code>クラスの<code>price</code>だとか<code>name</code>だとかについて、</p>

<p>それをソートするという操作は別に外のクラスが実装しても構わないけど、</p>

<p><code>Item</code>クラスが持っている方が何かと便利です。</p>

<p>したがって、オーダーするにあたって、<code>Item</code>クラスに次のようなメソッドを</p>

<p>持たせるようにします。</p>

<p>```java Item.java
public class Item {</p>

<pre><code>final String name;
final int price;
// 途中省略
public int comparePriceAscNameAsc (Item that) {
    int priceOrder = this.price - that.price;
    return priceOrder != 0 priceOrder :
            this.name.compareTo(that.name);
}
</code></pre>

<p>}
```</p>

<p>先ほどのソートをするコードのラムダ式部分は非常に簡単化されます。</p>

<p><code>java
items.sort((left, right) -&gt; left.comparePriceAscNameAsc(right));
</code></p>

<p>ところで、呼び出されるメソッドはこのケースの場合わかりきっているので、</p>

<blockquote><p>TODO : この記述は適当に書いているのでドキュメントを読み直します</p></blockquote>

<p>Method Referenceに変更することが可能です。</p>

<p><code>java
items.sort(Item::comparePriceAscNameAsc)
</code></p>

<p>という感じで、ラムダ式っぽい記述はなくなりました。</p>

<p>ちなみにMethod and Constructor Referenceは<a href="http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/C.html">Lambdaの仕様の一部</a>です。</p>

<p>{% render_partial _includes/post/post_footer.html %}</p>
]]></content>
  </entry>
  
</feed>
