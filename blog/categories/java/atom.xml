<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | mike、mikeなるままに…]]></title>
  <link href="http://mike-neck.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mike-neck.github.io/"/>
  <updated>2013-07-01T13:48:18+09:00</updated>
  <id>http://mike-neck.github.io/</id>
  <author>
    <name><![CDATA[mike-neck]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaFXをheadless browserとして使うためのJSObjectの扱い方 - 1]]></title>
    <link href="http://mike-neck.github.io/blog/2013/07/01/using-javafx-as-headless-browser/"/>
    <updated>2013-07-01T13:03:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/07/01/using-javafx-as-headless-browser</id>
    <content type="html"><![CDATA[<p>こんにちわ。</p>

<p>みけです。</p>

<p>JavaFXでjavascriptのテスティングフレームワークを作ろうと思ってから、</p>

<p>早1年半。</p>

<p>全然成果があがっていません。</p>

<p>今日は、そんな自分のための俺得なエントリー。</p>

<p><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRbkltQVpjMUkzNE0" style="width : 450px;"/></p>

<h2>Goal</h2>

<h4>期待していいこと</h4>

<ul>
<li>JSObjectでのarrayの取り扱い</li>
</ul>


<h4>期待できないこと</h4>

<ul>
<li>JavaFXのスレッドの同期方法</li>
<li>JSObjectでのobjectの取り扱い</li>
</ul>


<h2>JSObjectの扱い方 &ndash; array編</h2>

<p><code>JSObject#getSlot(int)</code>を使ってarrayの要素を取得します。</p>

<p>```java
final String script = &ldquo;(function(){return [&lsquo;a&rsquo;, 2, &lsquo;c&rsquo;, 4, &lsquo;e&rsquo;];})()&rdquo;;
final BlockingQueue<JSObject> queue = new LinkedBlockingQueue&lt;>();
Platform.runLater(() &ndash;> {</p>

<pre><code>queue.put((JSObject) webEngine.executeScript(script));
</code></pre>

<p>});
JSObject array = queue.take();
for (int i = 0; i &lt; 5; i++) {</p>

<pre><code>System.out.println(i + " -&gt; " + array.getSlot(i));
</code></pre>

<p>}
```</p>

<p>結果は次のようになります。</p>

<p><code>
0 -&gt; a
1 -&gt; 2
2 -&gt; c
3 -&gt; 4
4 -&gt; e
</code></p>

<p>ちなみに要素のindexより多い数を<code>JSObject#getSLot(int)</code>の引数に渡すと、</p>

<p><code>String</code>の<code>undefined</code>が返ってきます。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一回渋谷javaに行ってきた]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/30/first-shibuya-java/"/>
    <updated>2013-06-30T15:05:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/30/first-shibuya-java</id>
    <content type="html"><![CDATA[<p><a href="http://atnd.org/events/40140">第一回渋谷java</a>というのに行って来ました。</p>

<p>javaの勉強会としては比較的若い人の集まった勉強会だったと思います。</p>

<hr />

<p>自己紹介で「好きなEclipseのショートカットは？」とか聞かれたので、</p>

<p>相変わらずのことで「Eclipse氏ね」と答えて来ました。</p>

<p>後、Eclipseの代替するエディターがvimだったので、</p>

<p>いや、IntelliJ IDEAですからとも自己紹介しておきました。</p>

<hr />

<p>一応タイトルはネタっぽいですが、</p>

<p>真面目な話をして来ました。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/23694003" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>


<hr />

<p>他の参加者のブログがいくつかあるようです。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/jflute/20130629/1372519117">新たなるJavaの風景、渋谷javaがスタート！</a></li>
<li><a href="http://blog.k11i.biz/2013/06/java.html">第１回 #渋谷Java でトークしてきました</a></li>
<li><a href="http://hotchemi.hateblo.jp/entry/2013/06/29/230427">第1回渋谷Javaに行ってきた</a></li>
</ul>


<p>あと、いくつかスライドがアップロードされています。</p>

<p>JavaとOSS &ndash; ユーザーサイドから語ってみる</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/23660334" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/commonplace0807/java-23660334" title="渋谷Java第一回" target="_blank">渋谷Java第一回</a> </strong> from <strong><a href="http://www.slideshare.net/commonplace0807" target="_blank">commonplace0807</a></strong> </div></p>

<hr />

<p>今回は初回ということでLTだけでしたが、ハンズオンなども実施していくとのことです。</p>

<p>Eclipse強制されるのでなければ、行こうかなと思います。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java8 lambda式を使ってみた]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/27/java8-lambdashi-woshi-tutemita/"/>
    <updated>2013-06-27T22:24:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/27/java8-lambdashi-woshi-tutemita</id>
    <content type="html"><![CDATA[<p>こんにちわ、みけです。</p>

<p>Java8初心者勉強会というのを開催してみました。</p>

<p>参加者2人でした。</p>

<p>Java8はだれも興味ないんだなと思いました。</p>

<h2>Java8のラムダ式</h2>

<p>特にもうこれといって目新しいこともありません。</p>

<p>メソッドが一つだけのインターフェースを記述するときに、</p>

<p>非常に記述が楽になるというものです。</p>

<p>例えば次のようなクラスがあるとします。</p>

<p>```java Item.jara
public class Item {</p>

<pre><code>final String name;
final int price;
public Item(String name, int price) {
    this.name = name;
    this.price = price;
}
public String getName() {
    return name;
}
public int getPrice() {
    return price;
}
</code></pre>

<p>}
```</p>

<p>上記の<code>Item</code>クラスを<code>price</code>の昇順、<code>name</code>の昇順でソートするコードは以下のようになります。</p>

<p>```java
List<Item> items = getItemList();
items.sort((left, right) &ndash;> {</p>

<pre><code>int priceOrder = left.getPrice() - right.getPrice();
int nameOrder = left.getName().
        compareTo(right.getNmae());
return priceOrder != 0? priceOrder : nameOrder;
</code></pre>

<p>});
```</p>

<p>ところで、<code>Item</code>クラスの<code>price</code>だとか<code>name</code>だとかについて、</p>

<p>それをソートするという操作は別に外のクラスが実装しても構わないけど、</p>

<p><code>Item</code>クラスが持っている方が何かと便利です。</p>

<p>したがって、オーダーするにあたって、<code>Item</code>クラスに次のようなメソッドを</p>

<p>持たせるようにします。</p>

<p>```java Item.java
public class Item {</p>

<pre><code>final String name;
final int price;
// 途中省略
public int comparePriceAscNameAsc (Item that) {
    int priceOrder = this.price - that.price;
    return priceOrder != 0 priceOrder :
            this.name.compareTo(that.name);
}
</code></pre>

<p>}
```</p>

<p>先ほどのソートをするコードのラムダ式部分は非常に簡単化されます。</p>

<p><code>java
items.sort((left, right) -&gt; left.comparePriceAscNameAsc(right));
</code></p>

<p>ところで、呼び出されるメソッドはこのケースの場合わかりきっているので、</p>

<blockquote><p>TODO : この記述は適当に書いているのでドキュメントを読み直します</p></blockquote>

<p>Method Referenceに変更することが可能です。</p>

<p><code>java
items.sort(Item::comparePriceAscNameAsc)
</code></p>

<p>という感じで、ラムダ式っぽい記述はなくなりました。</p>

<p>ちなみにMethod and Constructor Referenceは<a href="http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/C.html">Lambdaの仕様の一部</a>です。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to publish artifacts to maven central repository via gradle maven-publish plugin (version 1.6)]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/21/how-to-publish-artifacts-with-gradle-maven-publish-plugin-version-1-dot-6/"/>
    <updated>2013-06-21T14:04:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/21/how-to-publish-artifacts-with-gradle-maven-publish-plugin-version-1-dot-6</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>Gradle <strong>maven-publish plugin</strong> provides the easier way to publish artifacts than the old <strong>maven plugin</strong>.</p>

<p>This post introduces you the way to publish artifacts with <strong>maven-publish plugin</strong>.</p>

<p><strong>Please Note that</strong> maven-publish plugin is incubating feature. Its DSL may change later.</p>

<h2>Goal</h2>

<p>After reading this post, you can upload your artifacts to maven central repository via <strong>maven-publish plugin</strong>.</p>

<h2>Basics and Example</h2>

<p>To publish artifacts you should do these things.</p>

<ol>
<li>to declare applying <strong>maven-publish plugin</strong>.</li>
<li>to tell gradle which files should be published.</li>
<li>to tell gradle where to upload artifacts.</li>
</ol>


<p>Now let&rsquo;s see sample build script.</p>

<p>```groovy build.gradle
// declaration of plugins (1)
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
group = &lsquo;com.yourdomain&rsquo;
version = &lsquo;1.0&rsquo;
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.apache.commons:commons-lang3:3.1'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        // telling gradle to publish project's jar archive (2)
        from components.java
        // telling gradle to publish README file (2)
        artifact ('README.txt') {
            classifier = 'README'
            extension  = 'txt'
        }
    }
}
// telling gradle to publish artifact to local directory (3)
repositories {
    maven {
        url "file:/${project.projectDir}/artifacts"
    }
}
</code></pre>

<p>}
```</p>

<p>With this script you can publish your artifact via this command.</p>

<p><code>
$ gradle publish
</code></p>

<p>Then you will find some file is generated at <code>artifact</code> directory.</p>

<p>These files are …</p>

<ul>
<li>sample-project.jar</li>
<li>sample-project.jar.md5</li>
<li>sample-project.jar.sha1</li>
<li>sample-project.pom</li>
<li>sample-project.pom.md5</li>
<li>sample-project.pom.sha1</li>
<li>sample-project-README.txt</li>
<li>sample-project-README.txt.md5</li>
<li>sample-project-README.txt.sha1</li>
</ul>


<h2>Conventions</h2>

<p><strong>maven-publish plugin</strong> has some conventions.</p>

<ul>
<li>base archive name is project name.</li>
<li><code>classifier</code> is given after the project name.</li>
<li><code>extension</code> is given after the project name and <code>classifier</code>.</li>
<li><code>classifier</code> and <code>extension</code> should be unique in all artifacts in a publication.</li>
</ul>


<h2>Publishing javadoc and source code as jar</h2>

<h3>javadoc</h3>

<p>Following shows the way to publish javadoc as jar.</p>

<ol>
<li>call javadoc task.</li>
<li>create a task of zipping javadoc and call it.</li>
<li>give th zipping task to <code>artifact</code> method in publication container.</li>
</ol>


<p>```groovy build.gradle
// (2)
task javadocJar (type: Jar, dependsOn: javadoc) { // (1)</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        artifact (javadocJar) { // (3)
            classifier = 'javadoc'
        }
    }
}
</code></pre>

<p>}
```</p>

<h3>source codes</h3>

<p>Following shows the way to publish source as jar.</p>

<ol>
<li>create a task of zipping sources as jar.</li>
<li>give the zipping task to <code>artifact</code> method in publication container.</li>
</ol>


<p>```groovy build.gradle
// (1)
task sourceJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        artifact (sourceJar) { // (2)
            classifier = 'sources'
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Modifying POM</h2>

<h3>requirements</h3>

<p><strong>maven-publish plugin</strong> generates POM, but it lacks some elements required by Sonatype OSS repository. Folowing shows list of elements to be added.</p>

<ul>
<li><code>&lt;name&gt;</code> &ndash; the name of project</li>
<li><code>&lt;description&gt;</code> &ndash; the description for the project</li>
<li><code>&lt;url&gt;</code> &ndash; project&rsquo;s url</li>
<li><code>&lt;scm&gt;&lt;url&gt;</code> &ndash; repository url.</li>
<li><code>&lt;scm&gt;&lt;connection&gt;</code> &ndash; repository url for scm tool. for example using git &ndash; github, it becomes <code>scm:git:git://github.com/your-name/project-name.git</code></li>
<li><code>&lt;scm&gt;&lt;developerConnection&gt;</code> &ndash; repository url for scm tool via ssh. for example using git &ndash; github, it becomes <code>scm:git:ssh:git@github.com:your-name/project-name.git</code></li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;name&gt;</code> &ndash; license name (i.e. <code>The Apache Software License, Version 2.0</code> etc…). In the case of the project being licensed under multiple license, <code>licenses</code> elements can have multiple <code>&lt;license&gt;</code> elements.</li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;url&gt;</code> &ndash; license url (e.x. if the project is licensed under Apache version 2, it becomes <code>http://www.apache.org/license/LICENSE-2.0.txt</code>)</li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;distribution&gt;</code> &ndash; <code>repo</code></li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;id&gt;</code> &ndash; developer&rsquo;s id. If there are more than one developers, you can write <code>&lt;developer&gt;</code> elements more than one times.</li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;name&gt;</code> &ndash; developer&rsquo;s name.</li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;email&gt;</code> &ndash; developer&rsquo;s email.</li>
</ul>


<h3>build script</h3>

<p>To add these elements to POM, you can acces pom file via <code>pom</code> object&rsquo;s <code>withXml</code> method in <code>MavenPublication</code> container.</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>publications {
    myPublication (MavenPublication) {
        from components.java
        pom.withXml {
            asNode().children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'project-name'
                description 'description for project'
                url projectUrl
                scm {
                    url scmUrl
                    connection connectionUrl
                    developerConnection developerConnectionUrl
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                developers {
                    developer {
                        id 'your id or nick name'
                        name 'Your Name'
                        email 'your@mail.address'
                    }
                }
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Signing Jar</h2>

<p>To keep quality of maven central repo, signing files is required.</p>

<p>These files should be signed.</p>

<ul>
<li>main jar (file name is <code>project-name.jar.asc</code>)</li>
<li>javadoc jar (file name is <code>project-name-javadoc.jar.asc</code>)</li>
<li>sources jar (file name is <code>project-name-sources.jar.asc</code>)</li>
<li>pom file (file name is <code>project-name.pom.asc</code>, on this signature this post will mention later)</li>
</ul>


<p>To sign archives is available via <strong>signing plugin</strong>.</p>

<p>```groovy build.gradle
// adding &lsquo;signing&rsquo; plugin
apply plugin: &lsquo;signing&rsquo;
// summarize artifacts
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign all artifacts
task signJars (type : Sign, dependsOn: [jar, javadocJar, sourceJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// call signJar task before publish task
task preparePublish(dependsOn: signJar)
// extract signature file and give them proper name
def getSignatureFiles = {</p>

<pre><code>def allFiles = project.tasks.signJars.signatureFiles.collect { it }
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    signatures (MavenPublication) {
        // give signature files to rtifact method
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Signing POM</h2>

<p>Before running <code>publish</code> task, there are no POM file, so calling signing POM task will fail. To avoid this, whether calling POM task or not is defined dynamicly. And writing POM is available <code>writeTo(File)</code> method via <code>XmlProviderContainer</code> (i.e. on the <code>Closure</code> block of <code>pom.withXml</code>)</p>

<p>```groovy build.gradle
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
task signPom(type: Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
if (project.ext.pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signJars, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signJars)
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    jar(MavenPublication) {
        // publishing main jars
        pom.withXml {
            // add required elements
            // here writing pom file
            if (!project.ext.pomFile.exists()) {
                writeTo (project.ext.pomFile)
            }
        }
    }
    gpgJars(MavenPublication) {
        // publishing signature of jars
    }
    // dynamic publication definition
    // pom file does exist signature of pom file is published
    if (project.ext.pomFile.exists()) {
        gpgPom(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        if (project.ext.pomFile.exists()) {
            url sonatypeUrl
            credentials {
                username = sonatypeUsername
                password = sonatypePassword
            }
        } else {
            url fileDirectory
        }
    }
}
</code></pre>

<p>}
```</p>

<p>and execute gradle tasks as follows</p>

<p><code>
$ gradle clean pP publish
$ gradle clean pP publish
</code></p>

<p>You should execute gradle publish task twice.</p>

<ol>
<li>The first execution is generating pom file and publishing som artifacts to machine&rsquo;s directory.</li>
<li>The second execution is publishing pom signature to Sonatype OSS repository.</li>
</ol>


<h4>Please note…</h4>

<p><code>publish</code> task will execute publication tasks according to the alphabetiacl order of publishing task name. And each publication task will generate POM file. So please take care of publication name. The recomending name for publications is …</p>

<ul>
<li>gpgJars &ndash; publish signatures of jar files.</li>
<li>gpgPom &ndash; publish signature of POM.</li>
<li>jar &ndash; publish all jars and POM.</li>
</ul>


<h2>Credential</h2>

<p>You may know an account of Sonatype OSS is required to upload artifact into maven central repo. Here shows settings of sonatype account in <strong>maven-publish plugin</strong>.</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>repositories {
    url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
    credentials {
        username = sonatypeUsername
        password = sonatypePassword
    }
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>Taking these things in account, here is a perfect example script for publishing artifacts to maven central repo with <strong>maven-publish plugin</strong>.</p>

<p>```groovy build.gradle
[&lsquo;java&rsquo;, &lsquo;siging&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plguin: it
</code></pre>

<p>}
// project information
group = &lsquo;com.yourdomain&rsquo;
version = &lsquo;1.0&rsquo;
// dependency management as you like
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.apache.commons:commons-lang3:3.1'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// javadoc.jar generation
task javadocJar (type: Jar, dependsOn: javadoc) { // (1)</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
// sources.jar generation
task sourceJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
// pom file name
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// add configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// summarize artifacts
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// sign all artifacts
task signJars (type : Sign, dependsOn: [jar, javadocJar, sourceJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// sign pom
task signPom(type: Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// defining which tasks should be called
if (project.ext.pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signJars, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signJars)
</code></pre>

<p>}
// extract signatures and add classifier and extension to them
def getSignatureFiles = {</p>

<pre><code>def allFiles = project.tasks.signJars.signatureFiles.collect { it }
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// extract pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publicaitons {
    gpgJars(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    if (project.ext.pomFile.exists()) {
        gpgPom(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
    jar(MavenPublication) {
        from components.java
        pom.withXml {
            asNode().children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'project-name'
                description 'description for project'
                url projectUrl
                scm {
                    url scmUrl
                    connection connectionUrl
                    developerConnection developerConnectionUrl
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                developers {
                    developer {
                        id 'your id or nick name'
                        name 'Your Name'
                        email 'your@mail.address'
                    }
                }
            }
        }
    }
}
repositories {
        if (project.ext.pomFile.exists()) {
            url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
            credentials {
                username = sonatypeUsername
                password = sonatypePassword
            }
        } else {
            url fileDirectory
        }
}
</code></pre>

<p>}
```</p>

<p>and execute gradle tasks as follows</p>

<p><code>
$ gradle clean pP publish
$ gradle clean pP publish
</code></p>

<p>… Eh? <strong>maven plugin</strong> is easier than this way? <strong>You, right!</strong></p>

<p>But this plugin will become more smart, I believe.</p>

<blockquote class="twitter-tweet"><p><a href="https://twitter.com/mike_neck">@mike_neck</a> You&#39;re doing cool stuff with &#39;maven-publish&#39;: latest gradle nightly has ability to set GAV of publication, too. Docs soon.</p>&mdash; Daz DeBoer (@dazdeboer) <a href="https://twitter.com/dazdeboer/statuses/347938407252635648">June 21, 2013</a></blockquote>


<script async src="http://mike-neck.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradleのmaven-publishプラグインでライブラリーを発行する方法 - 1]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1/"/>
    <updated>2013-06-19T16:21:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>ここ数日、gradleのmaven-publishプラグインにはまっていたので、</p>

<p>そのメモです。</p>

<p>なお、例によって長い記事なので、完成されたbuild.gradleだけ見たい方は、いっちばん下に行って下さい。</p>

<p>ただし、完成されたbuild.gradle読んでも理解できないと思いますけどね。</p>

<h1>maven-publishプラグインについて</h1>

<p>以下のとおりにメモしていきます。</p>

<ul>
<li>maven-publishプラグインの基礎</li>
<li>javadoc、sourcesを発行する</li>
<li>複数回、成果物を発行する</li>
<li>pomを変更する</li>
<li>PGP署名ファイルの発行</li>
<li>課題</li>
</ul>


<h2>maven-publishプラグインの基礎</h2>

<p>maven-publishプラグインは任意のファイルを</p>

<p>任意のmavenレポジトリーにアップロードすることができるプラグインです。</p>

<p>次のようなビルドスクリプトでは、以下のようなartifactを発行することができます。</p>

<ul>
<li>sample-project-1.0.jar</li>
<li>sample-project-1.0.pom</li>
<li>sample-project-1.0-doc.html</li>
</ul>


<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>また、これらに付随して、それぞれのファイルのmd5ファイルとsha1ファイルも作成されます。</p>

<p>実際に実行してみます。</p>

<p>```
$ gradle clean test publish
:clean UP-TO-DATE
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo
Transferring 0K from remote
Uploaded 0K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 18.255 secs
```</p>

<p>pomファイルが発行されたのかどうかよくわかりませんが、</p>

<p>実際に発行されたディレクトリーを見てみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample
$ ls
sample-project
$ cd sample-project/
$ ls
1.0    maven-metadata.xml    maven-metadata.xml.md5    maven-metadata.xml.sha1
$ cd 1.0/
$ ls
sample-project-1.0-doc.html      sample-project-1.0.jar      sample-project-1.0.pom
sample-project-1.0-doc.html.md5  sample-project-1.0.jar.md5  sample-project-1.0.pom.md5
sample-project-1.0-doc.html.sha1 sample-project-1.0.jar.sha1 sample-project-1.0.pom.sha1
</code></p>

<p>ということでコマンドを実行したあとの標準出力にはpomについての記述はありませんが、</p>

<p>ちゃんと発行されています。</p>

<h3>規約</h3>

<p>maven-publishプラグインでは以下のようなルールがあります。</p>

<ul>
<li>基本的なartifact名はproject名(ディレクトリの名前) + version番号</li>
<li><code>classifier</code>に指定された文字列は上記のファイル名の最後に付与される</li>
<li><code>extension</code>で指定された文字列は拡張子として付与される</li>
<li><code>classifier</code> + <code>extension</code>での一意性のチェックが行われる</li>
</ul>


<h2>javadoc、sourcesを発行する</h2>

<p>では、先ほどのサンプルに、ソースとjavadocを付与してみます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>DSLによれば、メソッド<code>artifact</code>にはtaskを引数にとることができ、指定したtaskの成果物を発行することができます。</p>

<p>上記の例では、<code>sourceJar</code>タスクによってjarファイルに固められたソースと、</p>

<p><code>javadocJar</code>タスクに寄ってjarファイルに固められたjavadocが、</p>

<p>発行されるようになります。</p>

<p>では、実行してみましょう。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:javadoc
:javadocJar
:sourceJar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 25.84 secs
```</p>

<p>上記の標準出力からソースとjavadocが出力されていることがわかります。</p>

<p>実際に出力されたファイルを確認してみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample/sample-project/1.0
$ ls -la
total 184
drwxr-xr-x  17 mike  mike   578B  6 19 17:40 .
drwxr-xr-x   6 mike  mike   204B  6 19 17:05 ..
-rw-r--r--   1 mike  mike   346B  6 19 17:40 sample-project-1.0-doc.html
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-doc.html.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-doc.html.sha1
-rw-r--r--   1 mike  mike    33K  6 19 17:40 sample-project-1.0-javadoc.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-javadoc.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-javadoc.jar.sha1
-rw-r--r--   1 mike  mike   927B  6 19 17:40 sample-project-1.0-sources.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-sources.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-sources.jar.sha1
-rw-r--r--   1 mike  mike   1.1K  6 19 17:40 sample-project-1.0.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.jar.sha1
-rw-r--r--   1 mike  mike   404B  6 19 17:40 sample-project-1.0.pom
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.pom.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.pom.sha1
</code></p>

<h2>複数回、成果物を発行する</h2>

<p>これまでの例では<code>sample</code>という発行タスクにいろいろなものを詰め込んでいました。</p>

<p>たとえば、javadocだけとか、sourcesファイルだけとか発行したい場合、</p>

<p>成果物の発行タスクを切り分けたいような場面があるかと思います。</p>

<p>その場合、<code>publications</code>の下の記述を変えることで、成果物の発行タスクを分けることができます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    // only java archives
    sample(MavenPublication) {
        from components.java
    }
    // publish documents
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>これで、メインのjarを発行するタスクと、</p>

<p>ドキュメント類を発行するタスクを切り分けることができました。</p>

<p>実際、タスクにはどのようなものがあるか確認します。</p>

<p>```
$ gradle tasks
:tasks</p>

<hr />

<h2>All tasks runnable from root project</h2>

<h2>Build tasks</h2>

<p>assemble &ndash; Assembles the outputs of this project.
build &ndash; Assembles and tests this project.</p>

<p>…中略…</p>

<h2>Publishing tasks</h2>

<p>publish &ndash; Publishes all publications produced by this project.
publishDocumentsPublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;documents&rsquo; to the local Maven repository.
publishDocumentsPublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;documents&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishSamplePublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;sample&rsquo; to the local Maven repository.
publishSamplePublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;sample&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishToMavenLocal &ndash; Publishes all Maven publications produced by this project to the local Maven cache.</p>

<p>…中略…</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.853 secs
```</p>

<p>Publishing tasksには次のようなエントリーが入っています。</p>

<ul>
<li><code>publish</code> すべてを指定したレポジトリーに発行する</li>
<li><code>publicDocumentsPublication…</code> <code>documents</code>で指定したアーカイブを発行します。</li>
<li><code>publishSamplePublication…</code> <code>sample</code>で指定したアーカイブを発行します。</li>
<li><code>publishToMavenLocal</code> すべてをmaven localレポジトリーに発行します。</li>
</ul>


<p>という形で、<code>publishing/publications</code>で複数のアーカイブ発行を指定することで、タスクが生成されます。</p>

<p>さて、ここでは、<code>publish</code>タスクを実行してみたいと思います。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForDocumentsPublication
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 12.33 secs
```</p>

<p>標準出力を見るとわかりますが、<strong>アルファベット順</strong>にタスクが実行されます。</p>

<p>そして、もう一つ気になるところがありますね。</p>

<p>各タスクの前に、<code>generatePomFileFor[タスク名]</code>というタスクが実行されています。</p>

<p>これらが発行するpomは何かを調べてみます。</p>

<p>まず、すこしスクリプトを変更します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p><code>dependencies</code>を追加しました。</p>

<p>この状態で、sampleの方を実行してみます。</p>

<blockquote><p>なお、このタスクの実行において、タスクの指定に省略名を使用しています。</p>

<p>gradleでは<code>publishToMavenRepository</code>のような単語の頭文字が大文字になっているタスクを</p>

<p>頭文字だけを選択して<code>pTMR</code>のように省略することができます。</p></blockquote>

<p>```
$ gradle clean pSPTMR
:clean
:generatePomFileForSamplePublication
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 2.498 secs
```</p>

<p>さて、この結果出力されたpomは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
</project>
```</p>

<p>一方、documentの方を実行してみます。</p>

<p>```
$ gradle clean pDPTMR
:clean
:generatePomFileForDocumentsPublication
:compileJava
:processResources UP-TO-DATE
:classes
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 4.961 secs
```</p>

<p>この結果出力されたpomは次のとおり、<code>&lt;dependencies&gt;</code>〜<code>&lt;/dependencies&gt;</code>の部分の記述がなくなります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
</project>
```</p>

<p>この違いは、前者のタスクにおいてdependenciesの情報を利用するのに対して、</p>

<p>後者はdependenciesを使わないことにあると勝手に理解しています。</p>

<p>したがって、複数回にわたって成果物を発行する場合は、</p>

<p>pomの生成について気をつけなければなりません。</p>

<h2>pomを変更する</h2>

<p>前回のポストで記述した通り、maven centralに登録するライブラリーについては、</p>

<p>発行するpomにいくつか追加情報を与えなければならない場合があります。</p>

<p>また、Jettyのservletを用いる場合は、</p>

<p>jetty-orbitという存在しないartifactを避けるために、</p>

<p>直接dependencyを書けない場合などがあります。</p>

<p>そのような場合に、pomを書き換える必要が生じます。</p>

<h3>publicationコンテナのpomオブジェクトを用いる</h3>

<p>maven-publishプラグインではpublicationコンテナにて</p>

<p>pomオブジェクトを介して発行されるpomにアクセスすることができます。</p>

<p>先ほどのビルドスクリプトにpomを生成するタスクを追加します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
    // editing pom file with builder style
    pomOnly(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>pomオブジェクトの<code>withXml</code>メソッドの引数の<code>Closure</code>は、</p>

<p><code>org.gradle.api.XmlProvider</code>のメソッドを呼び出すことができます。</p>

<p>そして、<code>asNode()</code>メソッドによりpomファイルを<code>groovy.util.Node</code>の形で取得出来ます。</p>

<p><code>asNode()</code>で返ってくる<code>Node</code>の一番トップの部分は<code>&lt;project&gt;</code>要素です。</p>

<p>この要素の子要素を取得し、最後の要素に<code>plus</code>メソッドで要素を追加します。</p>

<p>追加する<code>Closure</code>は、<code>groovy.util.NodeBuilder</code>と同等のDSLによって、</p>

<p>pomに要素を追加していくことができます。</p>

<p>では、このタスクを実行してみます。</p>

<p>```
$ gradle clean pPOPTMR
:clean
:generatePomFileForPomOnlyPublication
:publishPomOnlyPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 5.813 secs
```</p>

<p>発行されたpomファイルは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<h2>PGP署名ファイルの発行</h2>

<p>少し話題が飛びますが、</p>

<p>maven central repositoryにライブラリーを発行する場合、</p>

<p>各アーカイブファイルとpomファイルに対してPGP(Pretty Good Privacy)署名が必要となります。</p>

<h3>PGP署名って…？</h3>

<p>PGP署名を簡単に説明すると以下のようになります。</p>

<ul>
<li>配布物を元に、配布元で非公開鍵で暗号化して署名を作る</li>
<li>受け取り側で署名に対して公開鍵で復号化したものと、配布物とを比較する</li>
<li>一致していれば配布物が正しいもの(改ざんされていない)と判定される</li>
</ul>


<p>というファイルの信頼性を確認する仕組みです。</p>

<p>なお、PGPツールとしては、PGPの仕様RFC4880に準拠した、</p>

<p><a href="http://www.gnupg.org">GnuPG(Gnu Privacy Guard)</a>を使うのが一般的なようです。</p>

<p>なお、GnuPGの現在のバージョンは2.0です。</p>

<p>また、Javaでの実装ではBCPGが有名です。</p>

<p>また、gradle本題も<code>bcpg-jdk15-1.46</code>を利用しています。</p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0" style="width : 300px;"/></a></p>

<h3>署名タスクを作成する</h3>

<p>mavenプラグイン + signプラグインであれば、以下の様な記述で署名を作成することが可能です。</p>

<p>```groovy build.gradle
[&lsquo;maven&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
artifacts {</p>

<pre><code>archives jar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、maven-publishプラグインでは、明示的に署名ファイルも取り扱いたいので、</p>

<p>一工夫が必要になります。</p>

<p>```groovy build.gradle
// plugins see(1)
[&lsquo;maven-publish&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
// zip sources. see(4)
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
// zip javadocs. see(4)
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
// add classifier to jar file
classifier = 'javadoc'
</code></pre>

<p>}
// collect artifacts. see(3)
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign task. see(2)
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// execute sign task. see(7)
task preparePublication (dependsOn : signArchives)
// extracting signature files with classifier and extension. see(5)
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publishing artifacts
    jars(MavenPublication) {
        from components.java
        [
                [jarTask : tasks.sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : tasks.javadocJar, classifier : 'javadoc', extension : 'jar']                    
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.classifier
            }
        }
    }
    // publishing signature files. see(6)
    jarSignatures (MavenPublication) {
        getSignatureFiles().each {signedArchive -&gt;
            artifact (signedArchive.archive) {
                classifier = signedArchive.classifier
                extension  = signedArchive.extension
            }
        }
    }
    // publishing pom file
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'sample-project'
                description 'give information of gradle maven-publish plugin'
                url projectUrl
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                scm {
                    url github
                    connection scmUrl
                    developerConnection developerUrl
                }
                developers {
                    developer {
                        id 'mike_neck'
                        name 'Shinya Mochida'
                        email 'mike &lt;at&gt; mikeneck.org'
                    }
                }
            }
        }
    }
}
repositories {
    fladDirs "${project.projectDirs}/artifacts"
}
</code></pre>

<p>}
```</p>

<p>変更点は次のとおりです。</p>

<h4>(1) signingプラグインを導入します。</h4>

<p>signingプラグインではmavenプラグインと連携して次のように署名を作成することができます。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、mavenプラグインを使わないので、上記の方法では望みの署名ファイルを取得出来ません。</p>

<h4>(2) <code>Sign</code>タイプのタスクを作成する</h4>

<p>signingプラグインが入っているので、<code>type</code>が<code>Sign</code>のタスクを定義することができます。</p>

<p>このタスクを作成しておくと、指定したファイルに対して署名を作成することができます。</p>

<p>なお、このタスクは事前に署名対象のファイルがあることが前提なので、</p>

<p><code>jar</code>、<code>javadocJar</code>、<code>sourceJar</code>タスクに依存しています。</p>

<h4>(3) 成果物を一つの変数でアクセスできるようにする</h4>

<p><code>artifacts{}</code>ブロックでは指定した<code>configuration</code>に成果物を登録することができます。</p>

<p>次の例では<code>archives</code> configurationにjarタスク、javadocJarタスク、sourceJarタスクの成果を</p>

<p>登録します。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
```</p>

<p>これによって、<code>configurations.archives</code>というプロパティから、</p>

<p>各種タスクの成果物にアクセスできるようになります。</p>

<h4>(4) <code>Jar</code>タイプのタスクにclassifierを指定して、成果物のファイル名を修正します。</h4>

<p>```groovy build.gradle
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
```</p>

<p>これによって、作成されるsourcesJarのファイル名に<code>-sources</code>が含まれるようになります。</p>

<h4>(5) 署名ファイルを取り出します</h4>

<p><code>type</code>が<code>Sign</code>のタスクの<code>getSignatureFiles()</code>メソッドは、署名したファイルのリストを返します。</p>

<p>それらを<code>classifier</code>によって、わけて取り出して、</p>

<p>改めて<code>classifier</code>と<code>extension</code>を付与します。</p>

<h4>(6) 署名ファイルをそれぞれ発行します。</h4>

<p>上記の(5)のクロージャー<code>getSignatureFiles</code>によって、</p>

<p>署名ファイルと<code>classifier</code>と<code>extension</code>を取得し、</p>

<p>それぞれartifactとして登録、発行します。</p>

<h4>(7) 事前に実行しておくタスクをまとめたタスクを追加</h4>

<p>署名ファイルを作成するタスクを確実に実行しておくために、</p>

<p><code>preparePublication</code>タスクを作成します。</p>

<p>これを<code>publish</code>タスクの前に実行します。</p>

<hr />

<p>それでは<code>publish</code>タスクを実行してみます。</p>

<p>```
$gradle clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 10.894 secs
```</p>

<p>さて、署名ファイルが作成されているか確認します。</p>

<p><code>
$ cd /Users/mike/IdeaProjects/sample-project/artifacts/org/mikeneck/sample/sample-project/1.0
$ ls | grep asc
sample-project-1.0-javadoc.jar.asc
sample-project-1.0-javadoc.jar.asc.md5
sample-project-1.0-javadoc.jar.asc.sha1
sample-project-1.0-sources.jar.asc
sample-project-1.0-sources.jar.asc.md5
sample-project-1.0-sources.jar.asc.sha1
sample-project-1.0.jar.asc
sample-project-1.0.jar.asc.md5
sample-project-1.0.jar.asc.sha1
</code></p>

<p>それぞれ署名ファイルが作成されているようです。</p>

<p>では、署名ファイルを検証してみましょう。</p>

<p><code>
$ gpg2 --verify sample-project-1.0-javadoc.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0-sources.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>ちゃんと署名できていることが確認できました。</p>

<h2>課題</h2>

<p>さて、jarファイルの署名をすることは出来ました。</p>

<h4>pom署名ファイル問題</h4>

<p>しかし、残念なことにpomファイルの署名ができていません。</p>

<p>上述のpomファイルを変更するというところで記述した</p>

<p><code>org.gradle.api.XmlProvider</code>の実装クラスは</p>

<p><code>org.gradle.api.internal.xml.XmlTransformer.XmlProviderImpl</code>です。</p>

<p>そのクラスには<code>public void writeTo(java.io.File file)</code>というメソッドがあります。</p>

<p>そのメソッドを介してpomファイルを出力することが可能です。</p>

<p>したがって、次の手順でpomファイルの署名も発行することが可能ではないかと</p>

<p>考えられます。</p>

<ol>
<li>pom出力タスク中でpomファイルを書き出し</li>
<li>pom出力タスク中で書きだしたpomファイルの署名をするタスクを実行</li>
<li>pomファイルの署名をするタスクから署名ファイルを取得</li>
<li>署名ファイルをartifactとして発行</li>
</ol>


<p>上記の手順を実行するようにビルドスクリプトを書いてみます。</p>

<p>以下、一部抜粋。</p>

<p>```groovy build.gradle
// pom file
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// task for signing pom
task signPom(type : Sign) {</p>

<pre><code>sign pomFile
</code></pre>

<p>}
// getting a signature of pom
def getPomSignatrure = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publish pom
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.chidren().last() + {
                dependencies {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
            }
            writeTo(project.ext.pomFile)
            project.tasks.signPom.execute()
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>ではpublishタスクを実行してみます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository FAILED</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>What went wrong:
Execution failed for task &lsquo;:publishPomPublicationToMavenRepository&rsquo;.</p>

<blockquote><p>Failed to publish publication &lsquo;pom&rsquo; to repository &lsquo;maven&rsquo;
Invalid publication &lsquo;pom&rsquo;: artifact file does not exist: &lsquo;/Users/mike/IdeaProjects/sample-project/tmp/pom.xml.asc&rsquo;</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 5.357 secs
```</p>

<p><code>publishPomPublicationToMavenRepository</code>タスクで落ちてしまっています。</p>

<p>理由は署名ファイルが見つからないということです。</p>

<p>では、該当のディレクトリーの中身を見てみます。</p>

<p><code>
$ ls temp
pom.xml
</code></p>

<p>pomファイルだけしか出力されていません。</p>

<p>したがって、署名タスクが実行できてない状態になっているわけです。</p>

<p>実行されたタスクを挙げてみると、このようになっています。</p>

<ul>
<li>:clean</li>
<li>:compileJava</li>
<li>:processResources UP-TO-DATE</li>
<li>:classes</li>
<li>:jar</li>
<li>:javadoc</li>
<li>:javadocJar</li>
<li>:sourceJar</li>
<li>:signArchives</li>
<li>:preparePublication</li>
<li>:generatePomFileForJarSignaturesPublication</li>
<li>:publishJarSignaturesPublicationToMavenRepository</li>
<li>:generatePomFileForJarsPublication</li>
<li>:publishJarsPublicationToMavenRepository</li>
<li>:generatePomFileForPomPublication</li>
<li>:publishPomPublicationToMavenRepository FAILED</li>
</ul>


<p>よくみてみると、signPomタスクは実行されていません。</p>

<p>というわけで、明示的にsignPomタスクを実行する必要があるわけですが、</p>

<p>(<code>Task#execute()</code>で呼び出さないということ)</p>

<p><code>Task#dependsOn</code>でsignPomタスクを指定しても、発行できないだけでなく、</p>

<p>実際にはpublishing-publicationのコンテキストでは<code>dependsOn</code>が使えません。</p>

<p>先ほどのビルドスクリプトを一部変更してみます。</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            writeTo(project.ext.pomFile)
        }
        artifact (getPomSignature()) {
            classifier = null
            extension  = 'pom.asc'
        }
    }
}
</code></pre>

<p>}
```</p>

<p>このビルドスクリプトをパースさせると次のようなエラーが発生します。</p>

<p>```
$ gradle tasks
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>Where:
Build file &lsquo;/Users/mike/IdeaProjects/sample-project/build.gradle&rsquo; line: 90</p></li>
<li><p>What went wrong:
A problem occurred configuring root project &lsquo;sample-project&rsquo;.</p>

<blockquote><p>Cannot create a Publication named &lsquo;dependsOn&rsquo; because this container does not support creating elements by name alone. Please specify which subtype of Publication to create. Known subtypes are: MavenPublication</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 13.805 secs
```</p>

<p>たとえ、これがDSL上問題がなくても、</p>

<p>pomファイルの出力はsignPomタスクの後に実行されるので、</p>

<p>エラーが発生することは予見できます。</p>

<h4>現状考えられるpom署名ファイル回避方法</h4>

<p>gradleではダイナミックにタスクの定義ができます。</p>

<p>これを利用して、pomファイルがない場合は、</p>

<p>pomファイルの生成を行い、</p>

<p>一時的なファイルに対して発行を行います。</p>

<p>そして、pomファイルが存在する場合には、</p>

<p>署名タスクを実行して、</p>

<p>artifact登録して、maven repositoryへ発行します。</p>

<p>整理すると…</p>

<ul>
<li>maven publishプラグインを二回実行する。</li>
<li>pomファイルが存在しない場合は、signPomを実行しない、<code>withXml</code>で<code>writeTo</code>を使ってpomファイルを出力する。</li>
<li>pomファイルが存在する場合は、signPomを先に実行しておいて、署名ファイルもartifactとして発行する</li>
</ul>


<p>ということになります。</p>

<p>ビルドスクリプトを以下に示します(該当部分のみ)。</p>

<p>```groovy build.gradle
// dynamic definition of preparePublication
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// publishing if pomFile exists
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
        if (project.ext.pomFile.exists()) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        } else {
            delete(project.ext.pomFile)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>…で、これは実は失敗しました。</p>

<p>ヒントは、発行されるpomの<code>&lt;packaging&gt;&lt;/packaging&gt;</code>にあります。</p>

<ul>
<li>jarSignaturesタスクの場合は<code>&lt;packaging&gt;jar.asc&lt;/packaging&gt;</code></li>
<li>jarsタスクの場合は<code>&lt;packaging&gt;&lt;/packaging&gt;</code>要素なし</li>
<li>pomタスクの場合はpomFileが存在する場合は<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>、pomFileが存在しない場合は<code>&lt;packaging&gt;</code>要素なし</li>
</ul>


<p>となります。</p>

<p>pomFileが存在する場合に署名タスクを実行するという戦略をとっていたわけですが、</p>

<p>signPomタスクはpomFileが存在しない場合のpomファイル、</p>

<p>つまり<code>&lt;packaging&gt;</code>要素なしのものを元に署名を行うため、</p>

<p>同時に発行されるpomファイルが<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>を持ってしまうために、</p>

<p>署名ファイルが不適切なものになってしまうという不具合が発生してしまいました。</p>

<h4>改めてpomファイルの発行と、署名タスクの戦略を考えなおす</h4>

<h5>projectのメインのpom出力について</h5>

<p>先ほどの<code>&lt;packaging&gt;</code>要素に関しては、</p>

<p><code>groovy build.gradle
def node = = asNode()
def packagingNode = node.children().find{it.name().localPart.contains('packaging')}
node.remove(packageingNode)
</code></p>

<p>とやっても、発行されるartifactの<code>extension</code>によって、<code>&lt;packaging&gt;</code>要素が追加されてしまいます。</p>

<p>したがって、pomファイルの修正はjarファイルの発行タスクと同時に実施するのが望ましい形であると言えます。</p>

<p>なぜならば、jarファイルの発行タスクではすべての<code>extension</code>が<code>jar</code>であるため、</p>

<p>適切なpomファイルが作成されうるためです。</p>

<p>また、これはpomの署名ファイルの発行の元になるために、</p>

<p>ここでpomファイルの書き出しをしておく必要があります。</p>

<h5>署名ファイルの生成について</h5>

<p>pomファイルが存在している場合にのみ、署名タスクを実行、</p>

<p>署名ファイルアップロードするタスクが実行できるようにします。</p>

<h5>タスクの実行順について</h5>

<p>前述のとおり、pomファイルは後から実行されるタスクで上書きされていくので、</p>

<p>jarが発行されるタスクが一番最後に実施されるようにする必要があります。</p>

<p>その他の署名ファイルの発行タスクは、その先に実行されるようにします。</p>

<h4>以上の戦略に基づいたビルドスクリプト</h4>

<p>実行順序などに気をつけてビルドスクリプトを更新しました。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>publish タスクは二度実行します。</p>

<p>一度目はpomファイルを生成するだけが目的です。</p>

<p>二度目はpomの署名も生成して、すべてをmaven repositoryにアップロードします。</p>

<h4>一度目のpublishタスク実行結果</h4>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.149 secs
```</p>

<p>これは、あくまでpomファイルの生成を目的にしたpublish タスクです。</p>

<p>念の為にpomファイルを確認しておきます。</p>

<p>```
$ cat tmp/pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>これが次に実行するpublishタスクにて署名されてmaven repositoryにアップロードされます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:signPom UP-TO-DATE
:preparePublication
:generatePomFileForGpg-pomPublication
:publishGpg-pomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 8.249 secs
```</p>

<p>pom.ascファイルが無事発行されたようです。</p>

<p>それでは、適切なファイルであるかどうか、検証します。</p>

<p><code>
$ cd artifacts/org/mikeneck/sample/sample-project/1.0/
$ gpg2 --verify sample-project-1.0.pom.asc
gpg: Signature made 金  6/21 04:56:06 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>適切なファイルであることが検証できたようです。</p>

<p>また、pomファイルの<code>&lt;packaging&gt;</code>の部分がちゃんと<code>jar</code>になっているか</p>

<p>確認しておきます。</p>

<p>```
$ cat sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>ちゃんと<code>jar</code>になっているようなので、</p>

<p>全体的に成功であると判断出来ます。</p>

<h2>結論</h2>

<p>完成されたbuild.gradleファイルを再掲します。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>そして、artifactを発行するために、</p>

<p>次のコマンドを二度発行します。</p>

<p><code>
$ gradle clean pP publish
</code></p>

<p>これで、maven repositoryへ署名ファイル付きのリリースができるようになります。</p>

<p>次回は、今回の記事の要約文を掲載する予定です。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
</feed>
