<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: groovy | mike、mikeなるままに…]]></title>
  <link href="http://mike-neck.github.io/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://mike-neck.github.io/"/>
  <updated>2013-07-09T14:00:33+09:00</updated>
  <id>http://mike-neck.github.io/</id>
  <author>
    <name><![CDATA[mike-neck]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GradleのsetupBuildタスクを試してみた]]></title>
    <link href="http://mike-neck.github.io/blog/2013/07/09/trying-gradle-setupbuild-task-of-gradle-1-dot-7-rc1/"/>
    <updated>2013-07-09T10:54:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/07/09/trying-gradle-setupbuild-task-of-gradle-1-dot-7-rc1</id>
    <content type="html"><![CDATA[<p>こんにちわ。みけです。</p>

<p>前回の記事、<a href="http://mike-neck.github.io/blog/2013/07/06/gradle1-dot-7-release-notes-translation/">gradle1.7のリリースノート超意訳</a>で、</p>

<p>いくつか気になる機能があったので試してみることにしました。</p>

<hr />

<p>今回は、<a href="http://mike-neck.github.io/blog/2013/07/06/gradle1-dot-7-release-notes-translation/#c1_8">setupBuildタスク</a>を試してみます。</p>

<p>リリースノートでは</p>

<ul>
<li>javaプラグインが適用されたシンプルなビルドファイル</li>
<li>サンプルのプロダクションクラスとディレクトリー</li>
<li>サンプルのJUnitテストとディレクトリー</li>
<li>Gradle Wrapperファイル</li>
</ul>


<p>が生成されるとありました。</p>

<p>では実際に試してみたいと思います。</p>

<p>```
$ mkdir sample
$ cd sample/
$ ll
total 0
drwxr-xr-x  2 mike  staff    68B  7  9 11:19 .
drwxr-xr-x  3 mike  staff   102B  7  9 11:16 ..
$ gradle setupBuild &mdash;type java-library
:wrapper
:setupBuild</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 6.362 secs
$ ll
total 40
drwxr-xr-x  9 mike  staff   306B  7  9 11:19 .
drwxr-xr-x  3 mike  staff   102B  7  9 11:16 ..
drwxr-xr-x  3 mike  staff   102B  7  9 11:19 .gradle
-rw-r&mdash;r&mdash;  1 mike  staff   1.2K  7  9 11:19 build.gradle
drwxr-xr-x  3 mike  staff   102B  7  9 11:19 gradle
-rwxr-xr-x  1 mike  staff   5.0K  7  9 11:19 gradlew
-rw-r&mdash;r&mdash;  1 mike  staff   2.3K  7  9 11:19 gradlew.bat
-rw-r&mdash;r&mdash;  1 mike  staff   645B  7  9 11:19 settings.gradle
drwxr-xr-x  4 mike  staff   136B  7  9 11:19 src
```</p>

<p>お、見事プロジェクトが作成されています。</p>

<p>また、wrapperタスクを実行した後の状態になっていることもわかります。</p>

<p>(gradleディレクトリー、gradlewファイルとgradlew.batファイルが生成されている)</p>

<p>では、build.gradleの中身を見てみたいと思います。</p>

<p>```
$ cat build.gradle
/<em>
 * This build file was auto generated by running the Gradle &lsquo;buildSetup&rsquo; task
 * by &lsquo;mike&rsquo; at &lsquo;13/07/09 11:19&rsquo; with Gradle 1.7-rc-1
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at <a href="http://gradle.org/docs/1.7-rc-1/userguide/tutorial_java_projects.html">http://gradle.org/docs/1.7-rc-1/userguide/tutorial_java_projects.html</a>
 </em>/</p>

<p>// Apply the java plugin to add support for Java
apply plugin: &lsquo;java&rsquo;</p>

<p>// In this section you declare where to find the dependencies of your project
repositories {</p>

<pre><code>// Use 'maven central' for resolving your dependencies.
// You can declare any Maven/Ivy/file repository here.
mavenCentral()
</code></pre>

<p>}</p>

<p>// In this section you declare the dependencies for your production and test code
dependencies {</p>

<pre><code>// The production code uses the SLF4J logging API at compile time
compile 'org.slf4j:slf4j-api:1.7.5'

// Declare the dependency for your favourite test framework you want to use in your tests.
// TestNG is also supported by the Gradle Test task. Just change the
// testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
// 'test.useTestNG()' to your build script.
testCompile "junit:junit:4.11"
</code></pre>

<p>}
```</p>

<p>作成されたbuild.gradleファイルでは</p>

<ul>
<li>javaプラグインが適用されている</li>
<li>slf4jがコンパイル用のライブラリーとして登録されている</li>
<li>JUnitがテスト用のライブラリーとして登録されている</li>
</ul>


<p>ようです。</p>

<p>また、サンプルのプロダクションコードとテストコードが生成されるということですが、</p>

<ul>
<li><code>src/main/java/Library.java</code></li>
<li><code>src/test/java/LibraryTest.java</code></li>
</ul>


<p>の二つのファイルが作成されています。</p>

<p>それぞれの中身は次のようになっています。</p>

<p>```java Library.java
/<em>
 * This Java source file was auto generated by running &lsquo;gradle buildSetup &mdash;type java-library&rsquo;
 * by &lsquo;mike&rsquo; at &lsquo;13/07/09 11:19&rsquo; with Gradle 1.7-rc-1
 *
 * @author mike, @date 13/07/09 11:19
 </em>/
public class Library {</p>

<pre><code>public boolean someLibraryMethod() {
    return true;
}
</code></pre>

<p>}
```</p>

<p>```java LibraryTest.java
import org.junit.Test;
import static org.junit.Assert.*;</p>

<p>/<em>
 * This Java source file was auto generated by running &lsquo;gradle buildSetup &mdash;type java-library&rsquo;
 * by &lsquo;mike&rsquo; at &lsquo;13/07/09 11:19&rsquo; with Gradle 1.7-rc-1
 *
 * @author mike, @date 13/07/09 11:19
 </em>/
public class LibraryTest {</p>

<pre><code>@Test public void testSomeLibraryMethod() {
    Library classUnderTest = new Library();
    assertTrue("someLibraryMethod should return 'true'", classUnderTest.someLibraryMethod());
}
</code></pre>

<p>}
```</p>

<p>実際にこのコードを使うことはないと思いますが、</p>

<p>これまでmavenライクなディレクトリーを作るのが面倒だったので、</p>

<p>この<code>setupBuild</code>タスクができたことはGradleユーザーには朗報ですね。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle1.7のリリースノート超意訳]]></title>
    <link href="http://mike-neck.github.io/blog/2013/07/06/gradle1-dot-7-release-notes-translation/"/>
    <updated>2013-07-06T19:23:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/07/06/gradle1-dot-7-release-notes-translation</id>
    <content type="html"><![CDATA[<p><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRZHRNTkNwZEYtdkE"/></p>

<p>こんにちわ、みけです。</p>

<p>現在、gradle1.7-rc1が利用できます。</p>

<p>リリースノートの超意訳をどうぞ。</p>

<hr />

<h2>Gradle Release Notes</h2>

<h4>Version 1.7-rc-1</h4>

<p>Gradle1.7になるとすごく速くなります。dependency解決とビルドスクリプトのコンパイルの改善をしました。Gradleユーザーみんなこの恩恵に預かれますが、でっかいプロジェクトだと、その効果はもっと顕著になります。パフォーマンスの改善とスケービリティがGradle1.7の主要なテーマになっています。</p>

<p>これらの改善点に加えて、Gradle1.7では面白い機能がついてきます。finalizer taskメカニズムによってタスクの結果がどうであれ、タスクの次に別のタスクを起動させることができるようになります。例えば、アプリケーションサーバーを起動するようなintegrationテスト(の失敗)の後にアプリケーションサーバーを終了させることができるようになります。コピーやアーカイブ生成時にファイルの重複をコントロールする機能が登場します。</p>

<p>Gradle1.7のBuild Setupプラグインの改善によりプロジェクトをテンプレートから生成する機能が利用可能になります。これにより新規プロジェクトの作成が簡単になります。</p>

<p>C++からネイティブバイナリーを作成する機能も進化します。ネイティブバイナリーの生成に関しては結構面倒な領域ですが、今後もGradleのこの分野での進化を期待して下さい。</p>

<p>Gradle1.7ではコア・テベロップチーム以外からのコントリビュートが多いのも特徴です。Gradle1.7に貢献してくださったデベロッパーの皆様に感謝しております。</p>

<h2>Table Of Contents</h2>

<h3><a href="#c1">新機能や追加機能</a></h3>

<ul>
<li><a href="#c1_1">より速いGradleビルド</a></li>
<li><a href="#c1_2">Finalizer tasks</a></li>
<li><a href="#c1_3">C++プロジェクトサポートの改善</a></li>
<li><a href="#c1_4">JCenter レポジトリーのサポート</a></li>
<li><a href="#c1_5">パターン・ベース・ファイル・コピー設定</a></li>
<li><a href="#c1_6">ファイル重複時のハンドリング機能</a></li>
<li><a href="#c1_7">Gradle Wrapperはビルドスクリプトを特にいじらなくても利用可能になります</a></li>
<li><a href="#c1_8">Javaライブラリーテンプレートプロジェクトの生成</a></li>
<li><a href="#c1_9">publicationのカスタマイズ &ndash; new publishingプラグインにおける</a></li>
<li><a href="#c1_10">複数のモジュールを一つのGradleプロジェクトから発行する</a></li>
<li><a href="#c1_11">TestNGパラメーターがテストレポートに出力されます</a></li>
<li><a href="#c1_12">テストタスクに標準的なレポートインターフェースを採用</a></li>
<li><a href="#c1_13">ビルドダッシュボードの改善</a></li>
<li><a href="#c1_14">JUnit XMLファイルでテストケースごとにテストの出力を表示するようになりました</a></li>
<li><a href="#c1_15">ApplicationプラグインでJVMパラメーターを指定できるようになります</a></li>
<li><a href="#c1_16">BndライブラリーのアップデートによりOSGiサポートが改善されました</a></li>
</ul>


<h3><a href="#c2">修正された問題</a></h3>

<h3><a href="#c3">非推奨となったもの</a></h3>

<ul>
<li><a href="#c3_1">テストレポートプロパティ</a></li>
</ul>


<h3><a href="#c4">潜在的な互換性に関わる変更</a></h3>

<ul>
<li><a href="#c4_1">インメモリーdependencyキャッシング</a></li>
<li><a href="#c4_2">incubatingのJaCoCoプラグインの変更</a></li>
<li><a href="#c4_3">incubatingのbuild-setupプラグインの変更</a></li>
<li><a href="#c4_4">incubatingのivy-publishプラグインにおけるタスク名の変更</a></li>
<li><a href="#c4_5">IvyPublicationのデフォルト<code>status</code>値が<code>integration</code>となり、<code>project.status</code>でなくなりました</a></li>
<li><a href="#c4_6">C++サポートの大幅な変更</a></li>
<li><a href="#c4_7"><code>ConfigureableReport</code>が<code>ConfigurableReport</code>に名称が変わりました</a></li>
<li><a href="#c4_8">テストがない場合テストタスクがスキップされるようになりました</a></li>
<li><a href="#c4_9">OSGiプラグインに使われているBndライブラリーがアップデートされました</a></li>
</ul>


<h3><a href="#c5">コントリビューター</a></h3>

<h3><a href="#c6">既知の問題</a></h3>

<hr />

<p><span id="c1"></span></p>

<h3>新機能や追加機能</h3>

<p><span id="c1_1"></span></p>

<h5>より速いGradleビルド</h5>

<p>Gradle1.7でのビルドはより速くなります。</p>

<ul>
<li>dependency解決が速くなります(ほとんどのビルドで改善効果が現れます)</li>
<li>テスト実行が高速化されます(特にログを大量に出力しているようなGradleで顕著です)</li>
<li>ビルドスクリプトのコンパイルが速くなります(Gradle1.6に比べて75%の時間でできるようになります)</li>
<li>並行実行モードが高速になります</li>
</ul>


<p><span id="c1_2"></span></p>

<h5>Finalizer tasks <small>incubating</small></h5>

<p>Gradle1.7から新しいタスク実行ルールが導入され、タスク終了時に他のタスクを起動することができるようになります。この機能は<a href="https://github.com/erdi">Marcin Erdmann</a>氏によるものです。</p>

<p><a href="http://www.gradle.org/docs/release-candidate/userguide/more_about_tasks.html#N10F84">Finalizer tasks</a>ではタスク終了時にそのタスクの結果にかかわらず別のタスクを起動します。</p>

<p>```groovy
configure([integTest1, integTest2]) {</p>

<pre><code>dependsOn startAppServer
finalizedBy stopAppServer
</code></pre>

<p>}
```</p>

<p>この例では<code>integTest1</code>タスクと<code>integTest2</code>タスクの終了時に<code>stopAppServer</code>タスクを実行するように宣言されています。どちらか片方のタスクがビルドの最中に起動された場合もfinalizer taskが自動で実行されます。ビルドの最中に両方のタスクが起動された場合でも必ず両方のタスクの最後にfinalizer taskが実行されます。finalizer taskの<code>stopAppServer</code>はGradle実行時に起動タスクとして指定する必要はありません。</p>

<p><span id="c1_3"></span></p>

<h5>C++プロジェクトサポートの改善 <small>incubating</small></h5>

<p>GradleはC++プロジェクトのサポートをしていました。これはGradleをネイティブコードプロジェクトのビルドツールとして最良のものにする改善になります。</p>

<ul>
<li>スタティックライブラリーの作成、リンク作成</li>
<li>異なるC++ツールチェインでも利用可能になります(Visual C++、GCCなど)</li>
<li>異なるアーキテクチャー、ビルドタイプ、OSへの対応</li>
<li>Variantに基づいた依存性解決</li>
<li>その他もろもろ(詳しくは<a href="https://github.com/gradle/gradle/blob/master/design-docs/continuous-delivery-for-c-plus-plus.md">こちら</a>を見て下さい(英語))</li>
</ul>


<p><span id="c1_4"></span></p>

<h5>JCenter レポジトリーのサポート <small>incubating</small></h5>

<p><a href="https://bintray.com/bintray/jcenter">Bintray&rsquo;s JCenter Repository</a>からdependencyを取得できるようになります。<code>jcenter()</code>レポジトリーノーテーションにより利用可能です。JCenterはコミュニティリポジトリーで、<a href="https://bintray.com/">Bintray</a>から無料で配布可能です。</p>

<p>```groovy
repositories {</p>

<pre><code>jcenter()
</code></pre>

<p>}
```</p>

<p>このスクリプトにより<a href="http://jcenter.bintray.com">http://jcenter.bintray.com</a>がApache Maven repositoryと同様にリポジトリーリストに追加されます。</p>

<p><span id="c1_5"></span></p>

<h5>パターン・ベース・ファイル・コピー設定 <small>incubating</small></h5>

<p>Gradle1.7ではきめ細かい設定によりどのファイルがコピーされるべきかを定義することができます。設定方法は"Ant Patterns"のように指定出来ます。この機能は<a href="https://github.com/kylewm">Kyle Marhan</a>氏によるものです。</p>

<p>GradleにはファイルコピーのAPI(<a href="http://www.gradle.org/docs/release-candidate/javadoc/org/gradle/api/file/CopySpec.html">CopySpec</a>)があり、アーカイブすることもできます。この新しい機能はより強力なものとなります。</p>

<p>```groovy
task copyFiles(type : Copy) {</p>

<pre><code>from 'src/files'
into "$buildDir/copied-files"
// Replace the version number variable in only the text files
filesMaching('**/*.txt') {
    expand version: '1.0'
}
</code></pre>

<p>}
```</p>

<p><code>fileMatching</code>メソッドではClosureを引数に取り、<a href="http://www.gradle.org/docs/release-candidate/javadoc/org/gradle/api/file/FileCopyDetails.html"><code>FileCopyDetails</code></a>オブジェクトの設定を行うことができます。これと反対の動作をする<a href="http://www.gradle.org/docs/release-candidate/javadoc/org/gradle/api/file/CopySpec.html#filesNotMatching%28java.lang.String%2C%20org.gradle.api.Action%29"><code>filesNotMatching</code></a>というメソッドもあり、パターンに該当しないファイルすべてを指定することもできます。</p>

<p><span id="c1_6"></span></p>

<h5>ファイル重複時のハンドリング機能 <small>incubating</small></h5>

<p>ファイルのコピーやアーカイブするときに、よく重複することがあります。そのような重複が発生した場合の処理方法を設定できるようになります。</p>

<p>```groovy
task zip(type : Zip) {</p>

<pre><code>from 'dir1'
from 'dir2'
duplicatesStrategy 'exclude'
</code></pre>

<p>}
```</p>

<p>処理方法には２つあります。<code>include</code>と<code>exclude</code>です。</p>

<p><code>include</code>ストラテジーの場合、既存のGradleの動作と変わりありません。後からコピーされたもので上書きされます。なお、実際に発生した場合には警告が出力されるようになります。アーカイブ(zip、jar)の場合は新しいものが作成されます。</p>

<p><code>exclude</code>ストラテジーの場合、重複したファイルは無視されます。最初にコピーされたファイルが最終的に使われ、その後のファイルは無視され続けます。アーカイブの場合も同様で、最初に作成されたら、同じファイル名のものは作成されません。</p>

<p>```groovy
task zip (type : Zip) {</p>

<pre><code>duplicatesStrategy 'exclude' // default strategy
from ('dir1') {
    filesMatching('**/*.xml') {
        duplicatesStrategy 'include'
    }
}
from ('dir2') {
    duplicatesStrategy 'include'
}
</code></pre>

<p>}
```</p>

<p><span id="c1_7"></span></p>

<h5>Gradle Wrapperはビルドスクリプトを特にいじらなくても利用可能になります <small>incubating</small></h5>

<p><a href="http://www.gradle.org/docs/release-candidate/userguide/gradle_wrapper.html">Gradle Wrapper</a>は<code>Wrapper</code>タスクを定義しなくても利用できるようになります。つまり<code>Wrapper</code>のためにビルドスクリプトをいじることはありません。</p>

<p><code>Wrapper</code>を利用するためには単純に次のコマンドを実行するだけです。</p>

<p><code>
$ gradle wrapper
</code></p>

<p><code>Wrapper</code>ファイルがこれにより生成・設定されて、現在使用しているGradleのバージョンを利用することができるようになります。</p>

<p>なお、<code>wrapper</code>タスクをカスタマイズしたい場合は、ビルドスクリプトを次のように変更します。</p>

<p>```groovy
wrapper {</p>

<pre><code>gradleVersion '1.6'
</code></pre>

<p>}
```</p>

<p>もし既存の<code>Wrapper</code>タイプのタスクがある場合は、そちらが使われます。それ以外の場合はデフォルトの<code>wrapper</code>タスクが使用されます。</p>

<p><span id="c1_8"></span></p>

<h5>Javaライブラリーテンプレートプロジェクトの生成</h5>

<p>build-setupプラグインがプロジェクトタイプをサポートするようになりました。Gradle1.7ではjava-libraryタイプが利用可能です。このタイプで生成されるのは以下のとおりです。</p>

<ul>
<li>javaプラグインが適用されたシンプルなビルドファイル</li>
<li>サンプルのプロダクションクラスとディレクトリー</li>
<li>サンプルのJUnitテストとディレクトリー</li>
<li>Gradle Wrapperファイル</li>
</ul>


<p>Javaライブラリープロジェクトを作る場合は次のコマンドを実行するだけです(build.gradleファイルは必要ありません)。</p>

<p><code>
$ gradle setupBuild --type java-library
</code></p>

<p>詳しくはこちらを<a href="http://www.gradle.org/docs/release-candidate/userguide/build_setup_plugin.html">Build Setup plugin</a>を参照して下さい。</p>

<p><span id="c1_9"></span></p>

<h5>publicationのカスタマイズ &ndash; new publishingプラグインにおける <small>incubating</small></h5>

<p>publishプラグインでアーカイブを発行するときにartifactの情報を明示的にカスタマイズできるようになりました。以前はartifactの情報はプロジェクトの情報から取得されていました。</p>

<p><code>MavenPublication</code>では<code>groupId</code>、<code>artifactId</code>と<code>version</code>情報を設定できるようになります。Mavenの<code>pom</code>の<code>packaging</code>の値も設定可能です。</p>

<p>```groovy
publications {</p>

<pre><code>mavenPub(MaenPublication) {
    from components.java
    groupId 'my.group.id'
    artifactId 'my-publication'
    version '3.1'
    pom.packaging 'pom'
}
</code></pre>

<p>}
```</p>

<p><code>IvyPublication</code>では<code>organisation</code>、<code>module</code>と<code>revision</code>を設定出来ます。<code>IvyModuleDescriptor</code>で<code>status</code>の値も設定可能です。</p>

<p>```groovy
publications {</p>

<pre><code>ivyPub(IvyPublication) {
    from components.java
    organisation 'my.org'
    module 'my-module'
    revision '3'
    descriptor.status 'milestone'
}
</code></pre>

<p>}
```</p>

<p>この機能のすごいところは、<code>module</code>や<code>artifactId</code>を設定することができることです。というのも、これまでは<code>project.name</code>を使っており、Gradleのビルドスクリプトで変更することができなかったためです。</p>

<p><span id="c1_10"></span></p>

<h5>複数のモジュールを一つのGradleプロジェクトから発行する <small>incubating</small></h5>

<p>publishプラグインでは複数のモジュールを一つのGradleプロジェクトから発行することが可能になります。</p>

<p>```groovy
project.group &lsquo;org.cool.library&rsquo;
publications {</p>

<pre><code>implJar(MavenPublication) {
    artifactId 'cool-library'
    version '3.1'
    artifact jar
}
apiJar(MavenPublication) {
    artifactId 'cool-library-api'
    version '3'
    artifact apiJar
}
</code></pre>

<p>}
```</p>

<p>これまでも可能でしたが、ここに示したような簡単な方法ではできませんでした。新しい<code>ivy-publish</code>、<code>maven-publish</code>プラグインでは簡単に出来ます。</p>

<p><span id="c1_11"></span></p>

<h5>TestNGパラメーターがテストレポートに出力されます <small>incubating</small></h5>

<p>TestNGでは<a href="http://testng.org/doc/documentation-main.html#parameters">parameterizing test methods</a>によってあるテストを複数回、異なるデータの入力でテストを行うことがサポートされています。以前のGradleのレポートでは、パラメタライズドテストは複数行にわたってレポートが出力されていましたが、そのテストの区別をすることができませんでした。テストレポートにはパラメーターの<code>toString()</code>メソッドによる値を出力できるようにし、どのデータによるテストかを区別できるようにしました。</p>

<p>```java ParameterizedTest.java
import org.testng.annotations.*;</p>

<p>public class ParameterizedTest {</p>

<pre><code>@Test(dataProvider = "1")
public void aParameterizedTestCase(String var1, String var2) {
    // do testing
}

@DataProvider(name = "1")
public Object[][] provider1() {
    return new Object[][] {
       {"1", "2"},
       {"3", "4"}
    };
}
</code></pre>

<p>}
```</p>

<p>上記のテストに対するレポートは次のように表示されます。</p>

<ul>
<li><code>aParameterizedTestCase(1, 2)</code></li>
<li><code>aParameterizedTestCase(3, 4)</code></li>
</ul>


<p>この情報はGradleのHTMLテストレポートとJUnit XMLファイルに反映されます。JUnit XMLファイルは一般的にテストの実行結果をCIサーバーに引き渡す役割を担っており、CIサーバーでパラメーターの情報を参照することが可能になります。</p>

<p><span id="c1_12"></span></p>

<h5>テストタスクに標準的なレポートインターフェースを採用</h5>

<p>レポートインターフェースによりレポートをコントロールする方法が提供されます。テストタスクではこのレポートインターフェースが採用されます。</p>

<p>```groovy
apply plugin: &lsquo;java&rsquo;
test {</p>

<pre><code>reports {
    html.enabled = false
    junitXml.destination = file("$buildDir/junit-xml")
}
</code></pre>

<p>}
```</p>

<p>testタスクの提供する<a href="http://www.gradle.org/docs/release-candidate/javadoc/org/gradle/api/tasks/testing/TestReports.html">TestReports</a>型の<a href="http://www.gradle.org/docs/release-candidate/javadoc/org/gradle/api/reporting/ReportContainer.html"><code>ReportContainer</code></a>を通じて、HTMLによるテストレポートおよびJUnit XMLファイルの出力の制御を行えるようになります(これらのファイルは通常CIサーバーやその他のツールとテスト結果を共有するために使われます)。</p>

<p>これによりテストタスクも他のレポート生成タスクとAPIレベルで同等になります。また、不要であればJUnit XMLファイルを生成しないことも可能です。</p>

<p><span id="c1_13"></span></p>

<h5>ビルドダッシュボードの改善 <small>incubating</small></h5>

<p>上記の変更(テストタスクに標準的なレポートインターフェースを採用)は言い換えると、テストレポートが<a href="http://www.gradle.org/docs/release-candidate/userguide/buildDashboard_plugin.html">ビルドダッシュボード</a>に現れるということです。</p>

<p>なお、<code>buildDashbord</code>タスクは自動的にレポート系タスクと同時実行されます(Finalizerタスクの機能により実現されています)。</p>

<p><span id="c1_14"></span></p>

<h5>JUnit XMLファイルでテストケースごとにテストの出力を表示するようになりました <small>incubating</small></h5>

<p>この変更により<a href="http://jenkins-ci.org/">Jenkins</a>などのCIサーバーでよりよいテスト結果を得ることができます。</p>

<p>JUnit XMLファイルはテスト結果のフォーマットとしてデファクト・スタンダードです。たいていのCIサーバーはこのファイルをテストの実行結果として使っています。元々は「JUnit And Tasks」によって考えられたもので、JUnitとほぼ同時期に作られ、多くの局面で使われてきましたが、特に仕様が定められていませんでした。</p>

<p>このファイルにはテスト中の標準出力(<code>System.out</code>と<code>System.err</code>)の内容が収められています。これまでは出力は<em>クラスレベル</em>でのみ記録されていました。つまり、テストケース毎の出力が得られなかったわけです。しかしGradleでは「テストケース毎の出力」モードを利用することができるようになりました。</p>

<p>```groovy
test {</p>

<pre><code>reports {
    junitXml.outputPerTestCase = true
}
</code></pre>

<p>}
```</p>

<p>このモードを使うと、XMLレポートはテストケースごとに作成されます。Jenkins CIサーバーではテストケース毎の結果を参照できるようになります。<code>outputPerTestCase = true</code>と設定しておくと、テストケース毎の出力が画面に表示されます。以前は<em>テストクラス</em>毎の出力でした。</p>

<p>Jenkinsの<a href="https://wiki.jenkins-ci.org/display/JENKINS/JUnit+Attachments+Plugin">JUnit Attachments Plugin</a>はこの機能とともに用いることで有効活用できます。</p>

<p><span id="c1_15"></span></p>

<h5>ApplicationプラグインでJVMパラメーターを指定できるようになります <small>incubating</small></h5>

<p><a href="https://github.com/multi-io">Olaf Kilschat</a>により<a href="http://www.gradle.org/docs/release-candidate/userguide/application_plugin.html">Application Plugin</a>はデフォルトのJVM引数を設定することができるようになります。</p>

<p><code>groovy
apply plugin: 'application'
applicationDefaultJvmArgs = ['-Dfile.encoding=UTF-8']
</code></p>

<p><span id="c1_16"></span></p>

<h5>BndライブラリーのアップデートによりOSGiサポートが改善されました</h5>

<p><a href="http://www.gradle.org/docs/release-candidate/userguide/osgi_plugin.html">OSGi</a>プラグインは<a href="http://www.aqute.biz/Bnd/Bnd">Bnd</a>ツールを使ってbundle manifestsを作成しています。Bndツールのバージョンが1.50.0から2.1.0に変更されます。</p>

<p>最も重要な変更点は"invokedynamic"命令を使うJavaコード用のmanifestが正確になることです。</p>

<p><span id="c2"></span></p>

<h3>修正された問題</h3>

<p>Gradle1.7で30の問題が修正されました。</p>

<ul>
<li><a href="http://issues.gradle.org/browse/GRADLE-642">[GRADLE-642]</a> &ndash; scala toolsまたはライブラリーが登録されていない場合にscalaタスクから出力されるエラーメッセージを修正</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1289">[GRADLE-1289]</a> &ndash; &ldquo;create-project"コマンドによるスケルトンプロジェクト作成機能を提供</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1372">[GRADLE-1372]</a> &ndash; wrapperタスクをビルトインタスクにしました</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1387">[GRADLE-1387]</a> &ndash; Gradle Architypes機能を提供</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1456">[GRADLE-1456]</a> &ndash; Application PluginにてJAVA_OPTS/APPL_OPTSを設定する方法を提供</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1551">[GRADLE-1551]</a> &ndash; <a href="http://www.gradle.org/build_lifecycle.html%E3%81%AEtypo%E3%82%92%E4%BF%AE%E6%AD%A3">http://www.gradle.org/build_lifecycle.html%E3%81%AEtypo%E3%82%92%E4%BF%AE%E6%AD%A3</a></li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1583">[GRADLE-1583]</a> &ndash; Gradleがivy configurationの表現をサポートしていない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1704">[GRADLE-1704]</a> &ndash; &ldquo;gradle &mdash;version"コマンドの日付フォーマットの修正</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-1742">[GRADLE-1742]</a> &ndash; CodeNarcの警告数の上限を設定できるようにした</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2171">[GRADLE-2171]</a> &ndash; zipファイル生成する場合に重複を回避するオプションを提供</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2519">[GRADLE-2519]</a> &ndash; <code>testReport = false</code>と指定していてもテストFAILURE時に存在しないファイルのURLが表示される</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2666">[GRADLE-2666]</a> &ndash; maven2GradleでNullpointerが発生</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2702">[GRADLE-2702]</a> &ndash; testRuntime/testCompile configurationがテストがなくても解決される</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2738">[GRADLE-2738]</a> &ndash; dependenciesで同じartifactの複数のバージョンを指定している場合、一番古いバージョンで解決される</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2752">[GRADLE-2752]</a> &ndash; 自分自身のライブラリーの古いバージョンに依存している場合に</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2760">[GRADLE-2760]</a> &ndash; <code>--parallel-threads</code>が内部的に4つまでしか使えない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2765">[GRADLE-2765]</a> &ndash; XMLテストレポートを出力できない設定を追加</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2766">[GRADLE-2766]</a> &ndash; Ivy defaultConfMappingが解決に用いられない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2780">[GRADLE-2780]</a> &ndash; Gradle1.6でスクリプトのコンパイルが劣化</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2790">[GRADLE-2790]</a> &ndash; Ivy dependency configuration mapping <code>'*-&gt;@'</code> がターゲットモジュールからすべてのconfigurationを含んでしまう</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2791">[GRADLE-2791]</a> &ndash; Ivy dependency configuration mapping で左項<code>'%'</code>が無視される</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2792">[GRADLE-2792]</a> &ndash; Ivy dependency configuration mapping で左項<code>'*,!A'</code>がAの解決時に含まれてしまう</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2793">[GRADLE-2793]</a> &ndash; Ivy dependency configuration mapping で右項<code>'#'</code>が不適切なターゲットconfigurationに解される</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2802">[GRADLE-2802]</a> &ndash; Wrapperのインストール/ダウンロードが<code>-g</code>、<code>--gradle-user-home</code>コマンドラインフラグを考慮しない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2806">[GRADLE-2806]</a> &ndash; OSGiプラグインにBNDライブラリーの最新版を適用</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2808">[GRADLE-2808]</a> &ndash; <code>setting options.forkOptions.executable</code>と設定をしてjoint compileすると<code>NotSerializableException</code>が発生する</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2813">[GRADLE-2813]</a> &ndash; <code>project.exec()</code>でタスクを定義した場合、DSLが反映されない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2815">[GRADLE-2815]</a> &ndash; <code>@Input</code>が<code>boolean</code>型のgetterで<code>is*</code>という名前のメソッドには適用されない</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2821">[GRADLE-2821]</a> &ndash; テストのないテストタスクのレポート出力時にTestReportタスクがエラーを出力</li>
<li><a href="http://issues.gradle.org/browse/GRADLE-2825">[GRADLE-2825]</a> &ndash; <code>strategy</code>が<code>include</code>に設定されていてもファイル重複の警告が出力される</li>
</ul>


<p><span id="c3"></span></p>

<h3>非推奨となったもの</h3>

<p>Gradleの進化にともなって置き換えられたものや無駄になったものは<em>非推奨</em>になり、次のメジャーバージョン(Gradle2.0)にて廃止されます。ユーザーガイドの<a href="http://www.gradle.org/docs/release-candidate/userguide/feature_lifecycle.html">Feature Lifecycle</a>を参照して下さい。</p>

<p>以下に示すのが今回非推奨となったものです。もし何かあれば<a href="http://forums.gradle.org/">Gradle Forums</a>で問題提起してください。</p>

<p><span id="c3_1"></span></p>

<h5>テストレポートプロパティ</h5>

<p>Testタスクが<a href="http://www.gradle.org/docs/release-candidate/dsl/org.gradle.api.tasks.testing.Test.html">Reporting</a>インターフェースを実装するようになりました。現状のレポート出力に関するAPIは非推奨になりました。</p>

<ul>
<li><code>disableTestReport()</code></li>
<li><code>enableTestReport()</code></li>
<li><code>isTestReport()</code></li>
<li><code>setTestReport()</code></li>
<li><code>getTestReportDir()</code></li>
<li><code>setTestReportDir()</code></li>
<li><code>getTestResultsDir()</code></li>
<li><code>setTestResultsDir()</code></li>
</ul>


<p>すべての非推奨となった機能は新しい<a href="http://www.gradle.org/docs/release-candidate/dsl/org.gradle.api.tasks.testing.Test.html">Reporting</a>機能でも利用可能ではあります。</p>

<p><span id="c4"></span></p>

<h3>潜在的な互換性に関わる変更</h3>

<p><span id="c4_1"></span></p>

<h5>インメモリーdependencyキャッシング</h5>

<p>パフォーマンスの改善により、Gradleはdependencyの記述を<em>ビルド全般</em>にわたってメモリーにキャッシュするようになりました。つまりビルドの最中にdependencyメタデータが変わると、その変更はGradleは検知されない場合があります。このようなことが発生するパターンは確かめられていませんが、理論上想定することができます。</p>

<p>詳しくは<a href="http://www.gradle.org/docs/release-candidate/release-notes#faster-gradle-builds">Faster Gradle Builds</a>を参照下さい。</p>

<p><span id="c4_2"></span></p>

<h5>incubatingのJaCoCoプラグインの変更</h5>

<p><a href="http://www.gradle.org/docs/release-candidate/userguide/jacoco_plugin.html">JaCoCoカバレージプラグイン</a>のいくつかのクラスのプロパティの名前が適切なものに置き換わりました。</p>

<ul>
<li><code>JaCoCoTaskExtension.destPath</code>は<code>destinationFile</code>になりました。</li>
<li><code>JaCoCoTaskExtension.classDumpPath</code>は<code>classDumpFile</code>になりました。</li>
<li><code>JaCoCoMerge.destFile</code>は<code>destinationFile</code>になりました。</li>
</ul>


<p><span id="c4_3"></span></p>

<h5>incubatingのbuild-setupプラグインの変更</h5>

<p><code>ConvertMaven2Gradle</code>、<code>GenerateBuildScript</code>と<code>GenerateSettingsScript</code>クラスが削除されました。それらは<code>SetupBuild</code>型の<code>buildSetup</code>タスクの一部となっています。</p>

<p>プラグインはbuild-setupタイプに基づいて異なるタイプ・名前のタスクを作成します。</p>

<p><code>setupWrapper</code>タスクは<code>wrapper</code>となっています。</p>

<p><span id="c4_4"></span></p>

<h5>incubatingのivy-publishプラグインにおけるタスク名の変更</h5>

<p>maven-publishプラグインとの統一性を計るため、IvyPublicationでivy.xmlを生成するタスクが変わりました。タスクの名前は<code>generateDescriptorFileFor${publication.name}Publication</code>となります。</p>

<p><span id="c4_5"></span></p>

<h5>IvyPublicationのデフォルト<code>status</code>値が<code>integration</code>となり、<code>project.status</code>でなくなりました <small>incubating</small></h5>

<p>Ivy publicationモデルからGradleプロジェクトモデルを分離するために、<code>ivy-publish</code>プラグインで発行する際に<code>project.status</code>の値は使われなくなりました。</p>

<p><code>IvyPublication</code>の<code>IvyModuleDescriptor</code>用に<code>status</code>の値が設定されていない場合、デフォルトのivyステータス(<code>'integration'</code>)が使われます。以前は<code>project.status</code>のデフォルト値である<code>'release'</code>が使われていました。</p>

<p><span id="c4_6"></span></p>

<h5>C++サポートの大幅な変更</h5>

<p>GradleのincubatingなC++サポートがメジャーアップデートします。多くのプラグイン、タスク、APIクラス、DSLが変わります。この変更に伴いほとんどのシンプルなC++ビルドを変更する必要があります。</p>

<p>既存のC++ビルドを今後もGradleで実行するための対策は2つあります。</p>

<ol>
<li>Gradleを1.6のままにして、C++のサポートが安定するのを待ちます。その後、更新します。</li>
<li>最新の変更にビルドを合わせるようにします。なお、新たにリリースされた場合には変更が発生する可能性があります。</li>
</ol>


<p><span id="c4_7"></span></p>

<h5><code>ConfigureableReport</code>が<code>ConfigurableReport</code>に名称が変わりました</h5>

<p>incubatingの<code>org.gradle.api.reporting.ConfigureableReport</code>クラスは<code>org.gradle.api.reporting.ConfigurableReport</code>クラスに変更されます。ミススペルが原因です。</p>

<p><span id="c4_8"></span></p>

<h5>テストがない場合テストタスクがスキップされるようになりました</h5>

<p>テストがない場合には、テストタスクは<em>スキップ</em>されるようになります。<a href="http://issues.gradle.org/browse/GRADLE-2702">GRADLE-2702</a></p>

<p>以前はテストがない場合であっても、テストが実行されていました。その結果、dependencyの解決が実行され、何もないテストレポートが出力されていました。この変更によりビルドが高速になります。また、既存のビルドに対して大きな影響は発生しません。</p>

<p><span id="c4_9"></span></p>

<h5>OSGiプラグインに使われているBndライブラリーがアップデートされました</h5>

<p><a href="http://www.gradle.org/docs/release-candidate/userguide/osgi_plugin.html">OSGiプラグイン</a>でbundle manifestの生成に使われていた<a href="http://www.aqute.biz/Bnd/Bnd">Bnd</a>ツールのバージョンが1.50.0から2.1.0に上がります。</p>

<p>この変更は重要なアップグレードですが、後方互換性があります。</p>

<p><span id="c5"></span></p>

<h3>コントリビューター</h3>

<p>Gradleコミュニティの他に、Gradleのディベロップメントチームは下記の人達にこのバージョンのGradleへの貢献に感謝します。</p>

<h5><a href="https://github.com/erdi">Marchin Erdmann</a></h5>

<ul>
<li>Finalizer tasks</li>
</ul>


<h5><a href="https://github.com/dstine">Dan Stine</a></h5>

<ul>
<li>CodeNrcプラグインのmaxPriorityViolations setting (<a href="http://issues.gradle.org/browse/GRADLE-1742">GRADLE-1742</a>)</li>
<li>ユーザーガイドの修正</li>
</ul>


<h5><a href="https://github.com/kylewm">Kyle Mahan</a></h5>

<ul>
<li>アーカイブ・コピー操作における重複への対処(<a href="http://issues.gradle.org/browse/GRADLE-2171">GRADLE-2171</a>)</li>
<li>パターン・ベース・ファイル・コピー設定</li>
</ul>


<h5><a href="https://github.com/sponiro">Robert Kühne</a></h5>

<ul>
<li>ユーザーガイドのスペルミス修正</li>
</ul>


<h5><a href="https://github.com/Vampire">Björn Kautler</a></h5>

<ul>
<li>Build Dashboard のサンプルの修正</li>
</ul>


<h5><a href="https://github.com/sgoings">Seth Goings</a></h5>

<ul>
<li>ユーザーガイドの修正</li>
</ul>


<h5><a href="https://github.com/sbennettmcleish">Scott Bennett-McLeish</a></h5>

<ul>
<li>ユーザーガイドの修正</li>
</ul>


<h5><a href="https://github.com/wujek-srujek">Wujek Srujek</a></h5>

<ul>
<li>wrapperのインストールロケーションに関する-gコマンドラインオプションの処理(<a href="http://issues.gradle.org/browse/GRADLE-2802">GRADLE-2802</a>)</li>
</ul>


<h5><a href="https://github.com/glaforge">Guillaume Laforge</a></h5>

<ul>
<li>OSGiプラグインのBndライブラリーアップデート(<a href="http://issues.gradle.org/browse/GRADLE-2806">GRADLE-2806</a>)</li>
</ul>


<h5><a href="https://github.com/yoav">Yoav Landman</a></h5>

<ul>
<li><code>jcenter()</code>メソッドによるレポジトリー定義(<a href="https://bintray.com/bintray/jcenter">Bintray&rsquo;s JCenter repository</a>)</li>
</ul>


<p><span id="c6"></span></p>

<h3>既知の問題</h3>

<p>今のところGradle1.7に問題は見つかっていません。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to publish artifacts to maven central repository via gradle maven-publish plugin (version 1.6)]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/21/how-to-publish-artifacts-with-gradle-maven-publish-plugin-version-1-dot-6/"/>
    <updated>2013-06-21T14:04:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/21/how-to-publish-artifacts-with-gradle-maven-publish-plugin-version-1-dot-6</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>Gradle <strong>maven-publish plugin</strong> provides the easier way to publish artifacts than the old <strong>maven plugin</strong>.</p>

<p>This post introduces you the way to publish artifacts with <strong>maven-publish plugin</strong>.</p>

<p><strong>Please Note that</strong> maven-publish plugin is incubating feature. Its DSL may change later.</p>

<h2>Goal</h2>

<p>After reading this post, you can upload your artifacts to maven central repository via <strong>maven-publish plugin</strong>.</p>

<h2>Basics and Example</h2>

<p>To publish artifacts you should do these things.</p>

<ol>
<li>to declare applying <strong>maven-publish plugin</strong>.</li>
<li>to tell gradle which files should be published.</li>
<li>to tell gradle where to upload artifacts.</li>
</ol>


<p>Now let&rsquo;s see sample build script.</p>

<p>```groovy build.gradle
// declaration of plugins (1)
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
group = &lsquo;com.yourdomain&rsquo;
version = &lsquo;1.0&rsquo;
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.apache.commons:commons-lang3:3.1'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        // telling gradle to publish project's jar archive (2)
        from components.java
        // telling gradle to publish README file (2)
        artifact ('README.txt') {
            classifier = 'README'
            extension  = 'txt'
        }
    }
}
// telling gradle to publish artifact to local directory (3)
repositories {
    maven {
        url "file:/${project.projectDir}/artifacts"
    }
}
</code></pre>

<p>}
```</p>

<p>With this script you can publish your artifact via this command.</p>

<p><code>
$ gradle publish
</code></p>

<p>Then you will find some file is generated at <code>artifact</code> directory.</p>

<p>These files are …</p>

<ul>
<li>sample-project.jar</li>
<li>sample-project.jar.md5</li>
<li>sample-project.jar.sha1</li>
<li>sample-project.pom</li>
<li>sample-project.pom.md5</li>
<li>sample-project.pom.sha1</li>
<li>sample-project-README.txt</li>
<li>sample-project-README.txt.md5</li>
<li>sample-project-README.txt.sha1</li>
</ul>


<h2>Conventions</h2>

<p><strong>maven-publish plugin</strong> has some conventions.</p>

<ul>
<li>base archive name is project name.</li>
<li><code>classifier</code> is given after the project name.</li>
<li><code>extension</code> is given after the project name and <code>classifier</code>.</li>
<li><code>classifier</code> and <code>extension</code> should be unique in all artifacts in a publication.</li>
</ul>


<h2>Publishing javadoc and source code as jar</h2>

<h3>javadoc</h3>

<p>Following shows the way to publish javadoc as jar.</p>

<ol>
<li>call javadoc task.</li>
<li>create a task of zipping javadoc and call it.</li>
<li>give th zipping task to <code>artifact</code> method in publication container.</li>
</ol>


<p>```groovy build.gradle
// (2)
task javadocJar (type: Jar, dependsOn: javadoc) { // (1)</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        artifact (javadocJar) { // (3)
            classifier = 'javadoc'
        }
    }
}
</code></pre>

<p>}
```</p>

<h3>source codes</h3>

<p>Following shows the way to publish source as jar.</p>

<ol>
<li>create a task of zipping sources as jar.</li>
<li>give the zipping task to <code>artifact</code> method in publication container.</li>
</ol>


<p>```groovy build.gradle
// (1)
task sourceJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    myPublication(MavenPublication) {
        artifact (sourceJar) { // (2)
            classifier = 'sources'
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Modifying POM</h2>

<h3>requirements</h3>

<p><strong>maven-publish plugin</strong> generates POM, but it lacks some elements required by Sonatype OSS repository. Folowing shows list of elements to be added.</p>

<ul>
<li><code>&lt;name&gt;</code> &ndash; the name of project</li>
<li><code>&lt;description&gt;</code> &ndash; the description for the project</li>
<li><code>&lt;url&gt;</code> &ndash; project&rsquo;s url</li>
<li><code>&lt;scm&gt;&lt;url&gt;</code> &ndash; repository url.</li>
<li><code>&lt;scm&gt;&lt;connection&gt;</code> &ndash; repository url for scm tool. for example using git &ndash; github, it becomes <code>scm:git:git://github.com/your-name/project-name.git</code></li>
<li><code>&lt;scm&gt;&lt;developerConnection&gt;</code> &ndash; repository url for scm tool via ssh. for example using git &ndash; github, it becomes <code>scm:git:ssh:git@github.com:your-name/project-name.git</code></li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;name&gt;</code> &ndash; license name (i.e. <code>The Apache Software License, Version 2.0</code> etc…). In the case of the project being licensed under multiple license, <code>licenses</code> elements can have multiple <code>&lt;license&gt;</code> elements.</li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;url&gt;</code> &ndash; license url (e.x. if the project is licensed under Apache version 2, it becomes <code>http://www.apache.org/license/LICENSE-2.0.txt</code>)</li>
<li><code>&lt;licenses&gt;&lt;license&gt;&lt;distribution&gt;</code> &ndash; <code>repo</code></li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;id&gt;</code> &ndash; developer&rsquo;s id. If there are more than one developers, you can write <code>&lt;developer&gt;</code> elements more than one times.</li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;name&gt;</code> &ndash; developer&rsquo;s name.</li>
<li><code>&lt;developers&gt;&lt;developer&gt;&lt;email&gt;</code> &ndash; developer&rsquo;s email.</li>
</ul>


<h3>build script</h3>

<p>To add these elements to POM, you can acces pom file via <code>pom</code> object&rsquo;s <code>withXml</code> method in <code>MavenPublication</code> container.</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>publications {
    myPublication (MavenPublication) {
        from components.java
        pom.withXml {
            asNode().children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'project-name'
                description 'description for project'
                url projectUrl
                scm {
                    url scmUrl
                    connection connectionUrl
                    developerConnection developerConnectionUrl
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                developers {
                    developer {
                        id 'your id or nick name'
                        name 'Your Name'
                        email 'your@mail.address'
                    }
                }
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Signing Jar</h2>

<p>To keep quality of maven central repo, signing files is required.</p>

<p>These files should be signed.</p>

<ul>
<li>main jar (file name is <code>project-name.jar.asc</code>)</li>
<li>javadoc jar (file name is <code>project-name-javadoc.jar.asc</code>)</li>
<li>sources jar (file name is <code>project-name-sources.jar.asc</code>)</li>
<li>pom file (file name is <code>project-name.pom.asc</code>, on this signature this post will mention later)</li>
</ul>


<p>To sign archives is available via <strong>signing plugin</strong>.</p>

<p>```groovy build.gradle
// adding &lsquo;signing&rsquo; plugin
apply plugin: &lsquo;signing&rsquo;
// summarize artifacts
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign all artifacts
task signJars (type : Sign, dependsOn: [jar, javadocJar, sourceJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// call signJar task before publish task
task preparePublish(dependsOn: signJar)
// extract signature file and give them proper name
def getSignatureFiles = {</p>

<pre><code>def allFiles = project.tasks.signJars.signatureFiles.collect { it }
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    signatures (MavenPublication) {
        // give signature files to rtifact method
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h2>Signing POM</h2>

<p>Before running <code>publish</code> task, there are no POM file, so calling signing POM task will fail. To avoid this, whether calling POM task or not is defined dynamicly. And writing POM is available <code>writeTo(File)</code> method via <code>XmlProviderContainer</code> (i.e. on the <code>Closure</code> block of <code>pom.withXml</code>)</p>

<p>```groovy build.gradle
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
task signPom(type: Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
if (project.ext.pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signJars, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signJars)
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    jar(MavenPublication) {
        // publishing main jars
        pom.withXml {
            // add required elements
            // here writing pom file
            if (!project.ext.pomFile.exists()) {
                writeTo (project.ext.pomFile)
            }
        }
    }
    gpgJars(MavenPublication) {
        // publishing signature of jars
    }
    // dynamic publication definition
    // pom file does exist signature of pom file is published
    if (project.ext.pomFile.exists()) {
        gpgPom(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        if (project.ext.pomFile.exists()) {
            url sonatypeUrl
            credentials {
                username = sonatypeUsername
                password = sonatypePassword
            }
        } else {
            url fileDirectory
        }
    }
}
</code></pre>

<p>}
```</p>

<p>and execute gradle tasks as follows</p>

<p><code>
$ gradle clean pP publish
$ gradle clean pP publish
</code></p>

<p>You should execute gradle publish task twice.</p>

<ol>
<li>The first execution is generating pom file and publishing som artifacts to machine&rsquo;s directory.</li>
<li>The second execution is publishing pom signature to Sonatype OSS repository.</li>
</ol>


<h4>Please note…</h4>

<p><code>publish</code> task will execute publication tasks according to the alphabetiacl order of publishing task name. And each publication task will generate POM file. So please take care of publication name. The recomending name for publications is …</p>

<ul>
<li>gpgJars &ndash; publish signatures of jar files.</li>
<li>gpgPom &ndash; publish signature of POM.</li>
<li>jar &ndash; publish all jars and POM.</li>
</ul>


<h2>Credential</h2>

<p>You may know an account of Sonatype OSS is required to upload artifact into maven central repo. Here shows settings of sonatype account in <strong>maven-publish plugin</strong>.</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>repositories {
    url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
    credentials {
        username = sonatypeUsername
        password = sonatypePassword
    }
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>Taking these things in account, here is a perfect example script for publishing artifacts to maven central repo with <strong>maven-publish plugin</strong>.</p>

<p>```groovy build.gradle
[&lsquo;java&rsquo;, &lsquo;siging&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plguin: it
</code></pre>

<p>}
// project information
group = &lsquo;com.yourdomain&rsquo;
version = &lsquo;1.0&rsquo;
// dependency management as you like
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.apache.commons:commons-lang3:3.1'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// javadoc.jar generation
task javadocJar (type: Jar, dependsOn: javadoc) { // (1)</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
// sources.jar generation
task sourceJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
// pom file name
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// add configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// summarize artifacts
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// sign all artifacts
task signJars (type : Sign, dependsOn: [jar, javadocJar, sourceJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// sign pom
task signPom(type: Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// defining which tasks should be called
if (project.ext.pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signJars, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signJars)
</code></pre>

<p>}
// extract signatures and add classifier and extension to them
def getSignatureFiles = {</p>

<pre><code>def allFiles = project.tasks.signJars.signatureFiles.collect { it }
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// extract pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publicaitons {
    gpgJars(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    if (project.ext.pomFile.exists()) {
        gpgPom(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
    jar(MavenPublication) {
        from components.java
        pom.withXml {
            asNode().children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'project-name'
                description 'description for project'
                url projectUrl
                scm {
                    url scmUrl
                    connection connectionUrl
                    developerConnection developerConnectionUrl
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                developers {
                    developer {
                        id 'your id or nick name'
                        name 'Your Name'
                        email 'your@mail.address'
                    }
                }
            }
        }
    }
}
repositories {
        if (project.ext.pomFile.exists()) {
            url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
            credentials {
                username = sonatypeUsername
                password = sonatypePassword
            }
        } else {
            url fileDirectory
        }
}
</code></pre>

<p>}
```</p>

<p>and execute gradle tasks as follows</p>

<p><code>
$ gradle clean pP publish
$ gradle clean pP publish
</code></p>

<p>… Eh? <strong>maven plugin</strong> is easier than this way? <strong>You, right!</strong></p>

<p>But this plugin will become more smart, I believe.</p>

<blockquote class="twitter-tweet"><p><a href="https://twitter.com/mike_neck">@mike_neck</a> You&#39;re doing cool stuff with &#39;maven-publish&#39;: latest gradle nightly has ability to set GAV of publication, too. Docs soon.</p>&mdash; Daz DeBoer (@dazdeboer) <a href="https://twitter.com/dazdeboer/statuses/347938407252635648">June 21, 2013</a></blockquote>


<script async src="http://mike-neck.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradleのmaven-publishプラグインでライブラリーを発行する方法 - 1]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1/"/>
    <updated>2013-06-19T16:21:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>ここ数日、gradleのmaven-publishプラグインにはまっていたので、</p>

<p>そのメモです。</p>

<p>なお、例によって長い記事なので、完成されたbuild.gradleだけ見たい方は、いっちばん下に行って下さい。</p>

<p>ただし、完成されたbuild.gradle読んでも理解できないと思いますけどね。</p>

<h1>maven-publishプラグインについて</h1>

<p>以下のとおりにメモしていきます。</p>

<ul>
<li>maven-publishプラグインの基礎</li>
<li>javadoc、sourcesを発行する</li>
<li>複数回、成果物を発行する</li>
<li>pomを変更する</li>
<li>PGP署名ファイルの発行</li>
<li>課題</li>
</ul>


<h2>maven-publishプラグインの基礎</h2>

<p>maven-publishプラグインは任意のファイルを</p>

<p>任意のmavenレポジトリーにアップロードすることができるプラグインです。</p>

<p>次のようなビルドスクリプトでは、以下のようなartifactを発行することができます。</p>

<ul>
<li>sample-project-1.0.jar</li>
<li>sample-project-1.0.pom</li>
<li>sample-project-1.0-doc.html</li>
</ul>


<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>また、これらに付随して、それぞれのファイルのmd5ファイルとsha1ファイルも作成されます。</p>

<p>実際に実行してみます。</p>

<p>```
$ gradle clean test publish
:clean UP-TO-DATE
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo
Transferring 0K from remote
Uploaded 0K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 18.255 secs
```</p>

<p>pomファイルが発行されたのかどうかよくわかりませんが、</p>

<p>実際に発行されたディレクトリーを見てみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample
$ ls
sample-project
$ cd sample-project/
$ ls
1.0    maven-metadata.xml    maven-metadata.xml.md5    maven-metadata.xml.sha1
$ cd 1.0/
$ ls
sample-project-1.0-doc.html      sample-project-1.0.jar      sample-project-1.0.pom
sample-project-1.0-doc.html.md5  sample-project-1.0.jar.md5  sample-project-1.0.pom.md5
sample-project-1.0-doc.html.sha1 sample-project-1.0.jar.sha1 sample-project-1.0.pom.sha1
</code></p>

<p>ということでコマンドを実行したあとの標準出力にはpomについての記述はありませんが、</p>

<p>ちゃんと発行されています。</p>

<h3>規約</h3>

<p>maven-publishプラグインでは以下のようなルールがあります。</p>

<ul>
<li>基本的なartifact名はproject名(ディレクトリの名前) + version番号</li>
<li><code>classifier</code>に指定された文字列は上記のファイル名の最後に付与される</li>
<li><code>extension</code>で指定された文字列は拡張子として付与される</li>
<li><code>classifier</code> + <code>extension</code>での一意性のチェックが行われる</li>
</ul>


<h2>javadoc、sourcesを発行する</h2>

<p>では、先ほどのサンプルに、ソースとjavadocを付与してみます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>DSLによれば、メソッド<code>artifact</code>にはtaskを引数にとることができ、指定したtaskの成果物を発行することができます。</p>

<p>上記の例では、<code>sourceJar</code>タスクによってjarファイルに固められたソースと、</p>

<p><code>javadocJar</code>タスクに寄ってjarファイルに固められたjavadocが、</p>

<p>発行されるようになります。</p>

<p>では、実行してみましょう。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:javadoc
:javadocJar
:sourceJar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 25.84 secs
```</p>

<p>上記の標準出力からソースとjavadocが出力されていることがわかります。</p>

<p>実際に出力されたファイルを確認してみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample/sample-project/1.0
$ ls -la
total 184
drwxr-xr-x  17 mike  mike   578B  6 19 17:40 .
drwxr-xr-x   6 mike  mike   204B  6 19 17:05 ..
-rw-r--r--   1 mike  mike   346B  6 19 17:40 sample-project-1.0-doc.html
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-doc.html.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-doc.html.sha1
-rw-r--r--   1 mike  mike    33K  6 19 17:40 sample-project-1.0-javadoc.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-javadoc.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-javadoc.jar.sha1
-rw-r--r--   1 mike  mike   927B  6 19 17:40 sample-project-1.0-sources.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-sources.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-sources.jar.sha1
-rw-r--r--   1 mike  mike   1.1K  6 19 17:40 sample-project-1.0.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.jar.sha1
-rw-r--r--   1 mike  mike   404B  6 19 17:40 sample-project-1.0.pom
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.pom.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.pom.sha1
</code></p>

<h2>複数回、成果物を発行する</h2>

<p>これまでの例では<code>sample</code>という発行タスクにいろいろなものを詰め込んでいました。</p>

<p>たとえば、javadocだけとか、sourcesファイルだけとか発行したい場合、</p>

<p>成果物の発行タスクを切り分けたいような場面があるかと思います。</p>

<p>その場合、<code>publications</code>の下の記述を変えることで、成果物の発行タスクを分けることができます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    // only java archives
    sample(MavenPublication) {
        from components.java
    }
    // publish documents
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>これで、メインのjarを発行するタスクと、</p>

<p>ドキュメント類を発行するタスクを切り分けることができました。</p>

<p>実際、タスクにはどのようなものがあるか確認します。</p>

<p>```
$ gradle tasks
:tasks</p>

<hr />

<h2>All tasks runnable from root project</h2>

<h2>Build tasks</h2>

<p>assemble &ndash; Assembles the outputs of this project.
build &ndash; Assembles and tests this project.</p>

<p>…中略…</p>

<h2>Publishing tasks</h2>

<p>publish &ndash; Publishes all publications produced by this project.
publishDocumentsPublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;documents&rsquo; to the local Maven repository.
publishDocumentsPublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;documents&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishSamplePublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;sample&rsquo; to the local Maven repository.
publishSamplePublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;sample&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishToMavenLocal &ndash; Publishes all Maven publications produced by this project to the local Maven cache.</p>

<p>…中略…</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.853 secs
```</p>

<p>Publishing tasksには次のようなエントリーが入っています。</p>

<ul>
<li><code>publish</code> すべてを指定したレポジトリーに発行する</li>
<li><code>publicDocumentsPublication…</code> <code>documents</code>で指定したアーカイブを発行します。</li>
<li><code>publishSamplePublication…</code> <code>sample</code>で指定したアーカイブを発行します。</li>
<li><code>publishToMavenLocal</code> すべてをmaven localレポジトリーに発行します。</li>
</ul>


<p>という形で、<code>publishing/publications</code>で複数のアーカイブ発行を指定することで、タスクが生成されます。</p>

<p>さて、ここでは、<code>publish</code>タスクを実行してみたいと思います。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForDocumentsPublication
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 12.33 secs
```</p>

<p>標準出力を見るとわかりますが、<strong>アルファベット順</strong>にタスクが実行されます。</p>

<p>そして、もう一つ気になるところがありますね。</p>

<p>各タスクの前に、<code>generatePomFileFor[タスク名]</code>というタスクが実行されています。</p>

<p>これらが発行するpomは何かを調べてみます。</p>

<p>まず、すこしスクリプトを変更します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p><code>dependencies</code>を追加しました。</p>

<p>この状態で、sampleの方を実行してみます。</p>

<blockquote><p>なお、このタスクの実行において、タスクの指定に省略名を使用しています。</p>

<p>gradleでは<code>publishToMavenRepository</code>のような単語の頭文字が大文字になっているタスクを</p>

<p>頭文字だけを選択して<code>pTMR</code>のように省略することができます。</p></blockquote>

<p>```
$ gradle clean pSPTMR
:clean
:generatePomFileForSamplePublication
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 2.498 secs
```</p>

<p>さて、この結果出力されたpomは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
</project>
```</p>

<p>一方、documentの方を実行してみます。</p>

<p>```
$ gradle clean pDPTMR
:clean
:generatePomFileForDocumentsPublication
:compileJava
:processResources UP-TO-DATE
:classes
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 4.961 secs
```</p>

<p>この結果出力されたpomは次のとおり、<code>&lt;dependencies&gt;</code>〜<code>&lt;/dependencies&gt;</code>の部分の記述がなくなります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
</project>
```</p>

<p>この違いは、前者のタスクにおいてdependenciesの情報を利用するのに対して、</p>

<p>後者はdependenciesを使わないことにあると勝手に理解しています。</p>

<p>したがって、複数回にわたって成果物を発行する場合は、</p>

<p>pomの生成について気をつけなければなりません。</p>

<h2>pomを変更する</h2>

<p>前回のポストで記述した通り、maven centralに登録するライブラリーについては、</p>

<p>発行するpomにいくつか追加情報を与えなければならない場合があります。</p>

<p>また、Jettyのservletを用いる場合は、</p>

<p>jetty-orbitという存在しないartifactを避けるために、</p>

<p>直接dependencyを書けない場合などがあります。</p>

<p>そのような場合に、pomを書き換える必要が生じます。</p>

<h3>publicationコンテナのpomオブジェクトを用いる</h3>

<p>maven-publishプラグインではpublicationコンテナにて</p>

<p>pomオブジェクトを介して発行されるpomにアクセスすることができます。</p>

<p>先ほどのビルドスクリプトにpomを生成するタスクを追加します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
    // editing pom file with builder style
    pomOnly(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>pomオブジェクトの<code>withXml</code>メソッドの引数の<code>Closure</code>は、</p>

<p><code>org.gradle.api.XmlProvider</code>のメソッドを呼び出すことができます。</p>

<p>そして、<code>asNode()</code>メソッドによりpomファイルを<code>groovy.util.Node</code>の形で取得出来ます。</p>

<p><code>asNode()</code>で返ってくる<code>Node</code>の一番トップの部分は<code>&lt;project&gt;</code>要素です。</p>

<p>この要素の子要素を取得し、最後の要素に<code>plus</code>メソッドで要素を追加します。</p>

<p>追加する<code>Closure</code>は、<code>groovy.util.NodeBuilder</code>と同等のDSLによって、</p>

<p>pomに要素を追加していくことができます。</p>

<p>では、このタスクを実行してみます。</p>

<p>```
$ gradle clean pPOPTMR
:clean
:generatePomFileForPomOnlyPublication
:publishPomOnlyPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 5.813 secs
```</p>

<p>発行されたpomファイルは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<h2>PGP署名ファイルの発行</h2>

<p>少し話題が飛びますが、</p>

<p>maven central repositoryにライブラリーを発行する場合、</p>

<p>各アーカイブファイルとpomファイルに対してPGP(Pretty Good Privacy)署名が必要となります。</p>

<h3>PGP署名って…？</h3>

<p>PGP署名を簡単に説明すると以下のようになります。</p>

<ul>
<li>配布物を元に、配布元で非公開鍵で暗号化して署名を作る</li>
<li>受け取り側で署名に対して公開鍵で復号化したものと、配布物とを比較する</li>
<li>一致していれば配布物が正しいもの(改ざんされていない)と判定される</li>
</ul>


<p>というファイルの信頼性を確認する仕組みです。</p>

<p>なお、PGPツールとしては、PGPの仕様RFC4880に準拠した、</p>

<p><a href="http://www.gnupg.org">GnuPG(Gnu Privacy Guard)</a>を使うのが一般的なようです。</p>

<p>なお、GnuPGの現在のバージョンは2.0です。</p>

<p>また、Javaでの実装ではBCPGが有名です。</p>

<p>また、gradle本題も<code>bcpg-jdk15-1.46</code>を利用しています。</p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0" style="width : 300px;"/></a></p>

<h3>署名タスクを作成する</h3>

<p>mavenプラグイン + signプラグインであれば、以下の様な記述で署名を作成することが可能です。</p>

<p>```groovy build.gradle
[&lsquo;maven&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
artifacts {</p>

<pre><code>archives jar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、maven-publishプラグインでは、明示的に署名ファイルも取り扱いたいので、</p>

<p>一工夫が必要になります。</p>

<p>```groovy build.gradle
// plugins see(1)
[&lsquo;maven-publish&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
// zip sources. see(4)
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
// zip javadocs. see(4)
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
// add classifier to jar file
classifier = 'javadoc'
</code></pre>

<p>}
// collect artifacts. see(3)
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign task. see(2)
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// execute sign task. see(7)
task preparePublication (dependsOn : signArchives)
// extracting signature files with classifier and extension. see(5)
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publishing artifacts
    jars(MavenPublication) {
        from components.java
        [
                [jarTask : tasks.sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : tasks.javadocJar, classifier : 'javadoc', extension : 'jar']                    
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.classifier
            }
        }
    }
    // publishing signature files. see(6)
    jarSignatures (MavenPublication) {
        getSignatureFiles().each {signedArchive -&gt;
            artifact (signedArchive.archive) {
                classifier = signedArchive.classifier
                extension  = signedArchive.extension
            }
        }
    }
    // publishing pom file
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'sample-project'
                description 'give information of gradle maven-publish plugin'
                url projectUrl
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                scm {
                    url github
                    connection scmUrl
                    developerConnection developerUrl
                }
                developers {
                    developer {
                        id 'mike_neck'
                        name 'Shinya Mochida'
                        email 'mike &lt;at&gt; mikeneck.org'
                    }
                }
            }
        }
    }
}
repositories {
    fladDirs "${project.projectDirs}/artifacts"
}
</code></pre>

<p>}
```</p>

<p>変更点は次のとおりです。</p>

<h4>(1) signingプラグインを導入します。</h4>

<p>signingプラグインではmavenプラグインと連携して次のように署名を作成することができます。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、mavenプラグインを使わないので、上記の方法では望みの署名ファイルを取得出来ません。</p>

<h4>(2) <code>Sign</code>タイプのタスクを作成する</h4>

<p>signingプラグインが入っているので、<code>type</code>が<code>Sign</code>のタスクを定義することができます。</p>

<p>このタスクを作成しておくと、指定したファイルに対して署名を作成することができます。</p>

<p>なお、このタスクは事前に署名対象のファイルがあることが前提なので、</p>

<p><code>jar</code>、<code>javadocJar</code>、<code>sourceJar</code>タスクに依存しています。</p>

<h4>(3) 成果物を一つの変数でアクセスできるようにする</h4>

<p><code>artifacts{}</code>ブロックでは指定した<code>configuration</code>に成果物を登録することができます。</p>

<p>次の例では<code>archives</code> configurationにjarタスク、javadocJarタスク、sourceJarタスクの成果を</p>

<p>登録します。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
```</p>

<p>これによって、<code>configurations.archives</code>というプロパティから、</p>

<p>各種タスクの成果物にアクセスできるようになります。</p>

<h4>(4) <code>Jar</code>タイプのタスクにclassifierを指定して、成果物のファイル名を修正します。</h4>

<p>```groovy build.gradle
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
```</p>

<p>これによって、作成されるsourcesJarのファイル名に<code>-sources</code>が含まれるようになります。</p>

<h4>(5) 署名ファイルを取り出します</h4>

<p><code>type</code>が<code>Sign</code>のタスクの<code>getSignatureFiles()</code>メソッドは、署名したファイルのリストを返します。</p>

<p>それらを<code>classifier</code>によって、わけて取り出して、</p>

<p>改めて<code>classifier</code>と<code>extension</code>を付与します。</p>

<h4>(6) 署名ファイルをそれぞれ発行します。</h4>

<p>上記の(5)のクロージャー<code>getSignatureFiles</code>によって、</p>

<p>署名ファイルと<code>classifier</code>と<code>extension</code>を取得し、</p>

<p>それぞれartifactとして登録、発行します。</p>

<h4>(7) 事前に実行しておくタスクをまとめたタスクを追加</h4>

<p>署名ファイルを作成するタスクを確実に実行しておくために、</p>

<p><code>preparePublication</code>タスクを作成します。</p>

<p>これを<code>publish</code>タスクの前に実行します。</p>

<hr />

<p>それでは<code>publish</code>タスクを実行してみます。</p>

<p>```
$gradle clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 10.894 secs
```</p>

<p>さて、署名ファイルが作成されているか確認します。</p>

<p><code>
$ cd /Users/mike/IdeaProjects/sample-project/artifacts/org/mikeneck/sample/sample-project/1.0
$ ls | grep asc
sample-project-1.0-javadoc.jar.asc
sample-project-1.0-javadoc.jar.asc.md5
sample-project-1.0-javadoc.jar.asc.sha1
sample-project-1.0-sources.jar.asc
sample-project-1.0-sources.jar.asc.md5
sample-project-1.0-sources.jar.asc.sha1
sample-project-1.0.jar.asc
sample-project-1.0.jar.asc.md5
sample-project-1.0.jar.asc.sha1
</code></p>

<p>それぞれ署名ファイルが作成されているようです。</p>

<p>では、署名ファイルを検証してみましょう。</p>

<p><code>
$ gpg2 --verify sample-project-1.0-javadoc.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0-sources.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>ちゃんと署名できていることが確認できました。</p>

<h2>課題</h2>

<p>さて、jarファイルの署名をすることは出来ました。</p>

<h4>pom署名ファイル問題</h4>

<p>しかし、残念なことにpomファイルの署名ができていません。</p>

<p>上述のpomファイルを変更するというところで記述した</p>

<p><code>org.gradle.api.XmlProvider</code>の実装クラスは</p>

<p><code>org.gradle.api.internal.xml.XmlTransformer.XmlProviderImpl</code>です。</p>

<p>そのクラスには<code>public void writeTo(java.io.File file)</code>というメソッドがあります。</p>

<p>そのメソッドを介してpomファイルを出力することが可能です。</p>

<p>したがって、次の手順でpomファイルの署名も発行することが可能ではないかと</p>

<p>考えられます。</p>

<ol>
<li>pom出力タスク中でpomファイルを書き出し</li>
<li>pom出力タスク中で書きだしたpomファイルの署名をするタスクを実行</li>
<li>pomファイルの署名をするタスクから署名ファイルを取得</li>
<li>署名ファイルをartifactとして発行</li>
</ol>


<p>上記の手順を実行するようにビルドスクリプトを書いてみます。</p>

<p>以下、一部抜粋。</p>

<p>```groovy build.gradle
// pom file
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// task for signing pom
task signPom(type : Sign) {</p>

<pre><code>sign pomFile
</code></pre>

<p>}
// getting a signature of pom
def getPomSignatrure = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publish pom
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.chidren().last() + {
                dependencies {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
            }
            writeTo(project.ext.pomFile)
            project.tasks.signPom.execute()
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>ではpublishタスクを実行してみます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository FAILED</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>What went wrong:
Execution failed for task &lsquo;:publishPomPublicationToMavenRepository&rsquo;.</p>

<blockquote><p>Failed to publish publication &lsquo;pom&rsquo; to repository &lsquo;maven&rsquo;
Invalid publication &lsquo;pom&rsquo;: artifact file does not exist: &lsquo;/Users/mike/IdeaProjects/sample-project/tmp/pom.xml.asc&rsquo;</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 5.357 secs
```</p>

<p><code>publishPomPublicationToMavenRepository</code>タスクで落ちてしまっています。</p>

<p>理由は署名ファイルが見つからないということです。</p>

<p>では、該当のディレクトリーの中身を見てみます。</p>

<p><code>
$ ls temp
pom.xml
</code></p>

<p>pomファイルだけしか出力されていません。</p>

<p>したがって、署名タスクが実行できてない状態になっているわけです。</p>

<p>実行されたタスクを挙げてみると、このようになっています。</p>

<ul>
<li>:clean</li>
<li>:compileJava</li>
<li>:processResources UP-TO-DATE</li>
<li>:classes</li>
<li>:jar</li>
<li>:javadoc</li>
<li>:javadocJar</li>
<li>:sourceJar</li>
<li>:signArchives</li>
<li>:preparePublication</li>
<li>:generatePomFileForJarSignaturesPublication</li>
<li>:publishJarSignaturesPublicationToMavenRepository</li>
<li>:generatePomFileForJarsPublication</li>
<li>:publishJarsPublicationToMavenRepository</li>
<li>:generatePomFileForPomPublication</li>
<li>:publishPomPublicationToMavenRepository FAILED</li>
</ul>


<p>よくみてみると、signPomタスクは実行されていません。</p>

<p>というわけで、明示的にsignPomタスクを実行する必要があるわけですが、</p>

<p>(<code>Task#execute()</code>で呼び出さないということ)</p>

<p><code>Task#dependsOn</code>でsignPomタスクを指定しても、発行できないだけでなく、</p>

<p>実際にはpublishing-publicationのコンテキストでは<code>dependsOn</code>が使えません。</p>

<p>先ほどのビルドスクリプトを一部変更してみます。</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            writeTo(project.ext.pomFile)
        }
        artifact (getPomSignature()) {
            classifier = null
            extension  = 'pom.asc'
        }
    }
}
</code></pre>

<p>}
```</p>

<p>このビルドスクリプトをパースさせると次のようなエラーが発生します。</p>

<p>```
$ gradle tasks
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>Where:
Build file &lsquo;/Users/mike/IdeaProjects/sample-project/build.gradle&rsquo; line: 90</p></li>
<li><p>What went wrong:
A problem occurred configuring root project &lsquo;sample-project&rsquo;.</p>

<blockquote><p>Cannot create a Publication named &lsquo;dependsOn&rsquo; because this container does not support creating elements by name alone. Please specify which subtype of Publication to create. Known subtypes are: MavenPublication</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 13.805 secs
```</p>

<p>たとえ、これがDSL上問題がなくても、</p>

<p>pomファイルの出力はsignPomタスクの後に実行されるので、</p>

<p>エラーが発生することは予見できます。</p>

<h4>現状考えられるpom署名ファイル回避方法</h4>

<p>gradleではダイナミックにタスクの定義ができます。</p>

<p>これを利用して、pomファイルがない場合は、</p>

<p>pomファイルの生成を行い、</p>

<p>一時的なファイルに対して発行を行います。</p>

<p>そして、pomファイルが存在する場合には、</p>

<p>署名タスクを実行して、</p>

<p>artifact登録して、maven repositoryへ発行します。</p>

<p>整理すると…</p>

<ul>
<li>maven publishプラグインを二回実行する。</li>
<li>pomファイルが存在しない場合は、signPomを実行しない、<code>withXml</code>で<code>writeTo</code>を使ってpomファイルを出力する。</li>
<li>pomファイルが存在する場合は、signPomを先に実行しておいて、署名ファイルもartifactとして発行する</li>
</ul>


<p>ということになります。</p>

<p>ビルドスクリプトを以下に示します(該当部分のみ)。</p>

<p>```groovy build.gradle
// dynamic definition of preparePublication
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// publishing if pomFile exists
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
        if (project.ext.pomFile.exists()) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        } else {
            delete(project.ext.pomFile)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>…で、これは実は失敗しました。</p>

<p>ヒントは、発行されるpomの<code>&lt;packaging&gt;&lt;/packaging&gt;</code>にあります。</p>

<ul>
<li>jarSignaturesタスクの場合は<code>&lt;packaging&gt;jar.asc&lt;/packaging&gt;</code></li>
<li>jarsタスクの場合は<code>&lt;packaging&gt;&lt;/packaging&gt;</code>要素なし</li>
<li>pomタスクの場合はpomFileが存在する場合は<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>、pomFileが存在しない場合は<code>&lt;packaging&gt;</code>要素なし</li>
</ul>


<p>となります。</p>

<p>pomFileが存在する場合に署名タスクを実行するという戦略をとっていたわけですが、</p>

<p>signPomタスクはpomFileが存在しない場合のpomファイル、</p>

<p>つまり<code>&lt;packaging&gt;</code>要素なしのものを元に署名を行うため、</p>

<p>同時に発行されるpomファイルが<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>を持ってしまうために、</p>

<p>署名ファイルが不適切なものになってしまうという不具合が発生してしまいました。</p>

<h4>改めてpomファイルの発行と、署名タスクの戦略を考えなおす</h4>

<h5>projectのメインのpom出力について</h5>

<p>先ほどの<code>&lt;packaging&gt;</code>要素に関しては、</p>

<p><code>groovy build.gradle
def node = = asNode()
def packagingNode = node.children().find{it.name().localPart.contains('packaging')}
node.remove(packageingNode)
</code></p>

<p>とやっても、発行されるartifactの<code>extension</code>によって、<code>&lt;packaging&gt;</code>要素が追加されてしまいます。</p>

<p>したがって、pomファイルの修正はjarファイルの発行タスクと同時に実施するのが望ましい形であると言えます。</p>

<p>なぜならば、jarファイルの発行タスクではすべての<code>extension</code>が<code>jar</code>であるため、</p>

<p>適切なpomファイルが作成されうるためです。</p>

<p>また、これはpomの署名ファイルの発行の元になるために、</p>

<p>ここでpomファイルの書き出しをしておく必要があります。</p>

<h5>署名ファイルの生成について</h5>

<p>pomファイルが存在している場合にのみ、署名タスクを実行、</p>

<p>署名ファイルアップロードするタスクが実行できるようにします。</p>

<h5>タスクの実行順について</h5>

<p>前述のとおり、pomファイルは後から実行されるタスクで上書きされていくので、</p>

<p>jarが発行されるタスクが一番最後に実施されるようにする必要があります。</p>

<p>その他の署名ファイルの発行タスクは、その先に実行されるようにします。</p>

<h4>以上の戦略に基づいたビルドスクリプト</h4>

<p>実行順序などに気をつけてビルドスクリプトを更新しました。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>publish タスクは二度実行します。</p>

<p>一度目はpomファイルを生成するだけが目的です。</p>

<p>二度目はpomの署名も生成して、すべてをmaven repositoryにアップロードします。</p>

<h4>一度目のpublishタスク実行結果</h4>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.149 secs
```</p>

<p>これは、あくまでpomファイルの生成を目的にしたpublish タスクです。</p>

<p>念の為にpomファイルを確認しておきます。</p>

<p>```
$ cat tmp/pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>これが次に実行するpublishタスクにて署名されてmaven repositoryにアップロードされます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:signPom UP-TO-DATE
:preparePublication
:generatePomFileForGpg-pomPublication
:publishGpg-pomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 8.249 secs
```</p>

<p>pom.ascファイルが無事発行されたようです。</p>

<p>それでは、適切なファイルであるかどうか、検証します。</p>

<p><code>
$ cd artifacts/org/mikeneck/sample/sample-project/1.0/
$ gpg2 --verify sample-project-1.0.pom.asc
gpg: Signature made 金  6/21 04:56:06 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>適切なファイルであることが検証できたようです。</p>

<p>また、pomファイルの<code>&lt;packaging&gt;</code>の部分がちゃんと<code>jar</code>になっているか</p>

<p>確認しておきます。</p>

<p>```
$ cat sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>ちゃんと<code>jar</code>になっているようなので、</p>

<p>全体的に成功であると判断出来ます。</p>

<h2>結論</h2>

<p>完成されたbuild.gradleファイルを再掲します。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>そして、artifactを発行するために、</p>

<p>次のコマンドを二度発行します。</p>

<p><code>
$ gradle clean pP publish
</code></p>

<p>これで、maven repositoryへ署名ファイル付きのリリースができるようになります。</p>

<p>次回は、今回の記事の要約文を掲載する予定です。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle 1.4以降から追加されているmaven-publishプラグインでは、まだmaven central レポジトリーに上げられないようです。]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/15/publishing-artifact-with-gradles-new-maven-publish-plugin-is-currently-unavailable/"/>
    <updated>2013-06-15T15:53:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/15/publishing-artifact-with-gradles-new-maven-publish-plugin-is-currently-unavailable</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>あ、また、例によって記事が長いので、</p>

<p>結論だけ見たい人は前半部分だけを見て下さい。 &ndash; 大体5分以内。</p>

<p>で、gradleでのmaven centralへのライブラリー登録方法を知りたい方は中盤部分まで読んで下さい。 &ndash; トータル15分。</p>

<p>で、僕の強引なgradle遊びまで読みたい方は最後まで読むといいかもしれません。 &ndash; トータル30分。</p>

<hr />

<p><strong>前半部分</strong></p>

<p>ここ数日gradle1.4以降についかされた<strong>maven-publish</strong>プラグインを使って</p>

<p>maven centralへのライブラリー登録方法を調べていましたが、</p>

<h1>maven-publishプラグインでのmaven central repoへの登録はまだサポートされてません</h1>

<p>ようです。</p>

<p>元記事はこちらです。</p>

<ul>
<li><a href="http://forums.gradle.org/gradle/topics/how_to_publish_artifacts_signatures_asc_files_using_maven_publish_plugin">How to publish artifacts signatures (.asc files) using maven-publish plugin?</a></li>
</ul>


<p>以下、簡単な意訳＋要約文</p>

<blockquote><h3>質問</h3>

<p>maven-publishプラグインを使ってレポジトリー情報の設定と、それと別個に、singningプラグインを使ってartifactsへのサインを行うことができますが、それらを連携させることができません。</p>

<p>どのようにすればmaven-publishプラグインで、artifactsとサインファイル(.ascファイル)をアップロードするようにできますか？</p>

<h3>回答</h3>

<p>今のところmaven-publishプラグインを使ってartifactとsignatureをアップロードすることはサポートされていません。<strong>Gradle</strong>に「.asc」ファイル(サインしたファイル)が通常のartifactではなく、特別なartifactであることを伝える手段がないことが問題となっています。</p>

<p><a href="https://github.com/gradle/gradle/blob/master/design-docs/publication-model.md">こちらのロードマップ</a>を参照下さい。なお、この機能に関する優先順位は高くありません。</p>

<h3>再質問</h3>

<p>現在、古い方法でのアップロードはサポートされていますか？それとも手作業でやらないと駄目ですか？</p>

<h3>回答</h3>

<p>古い方法でのアップロードは利用できます。</p>

<h3>提案</h3>

<p>ありがとうございました。</p>

<p>ところで、ドキュメントの方で新しいプラグインではmaven centralにアップロード出来ないという記述がないので追加してもらえますか？</p></blockquote>

<p>とのことで、maven-publishプラグインでのmaven central repoへのアップロードはまだ対応されていないようです。これはこれで従来のmavenプラグインよりも便利なので、maven centralへのアップロードも可能になって欲しいとろこです。</p>

<hr />

<p><strong>中盤部分</strong></p>

<p>なお、日本語でも情報は入手出来ますが、念の為にこちらにも記述しておきます。</p>

<h1>現状のgradleを用いたmaven centralへのアップロード方法</h1>

<p>概要は、山本裕介氏のこちらの記事を参照して下さい。</p>

<ul>
<li><a href="http://samuraism.jp/diary/2012/05/03/1336047480000.html">【最新版】Maven Central Repository へのライブラリ登録方法 #maven</a></li>
</ul>


<p>また、gradleでの方法についてはこちらを参照して下さい。</p>

<ul>
<li><a href="http://jedicoder.blogspot.jp/2011/11/automated-gradle-project-deployment-to.html">Automated Gradle project deployment to Sonatype OSS Repository(英語)</a></li>
<li><a href="http://d.hatena.ne.jp/int128/20130409/1365434513">GradleでMaven Central Repositoryに成果物をリリースする(日本語)</a></li>
</ul>


<p>両方の記事に共通していますが、Sonatypeからmaven centralにアップロードする場合は、</p>

<ul>
<li>PGPによる署名の作成</li>
<li>求められた規約の順守</li>
</ul>


<p>が求められます。</p>

<h3>なんでこんな面倒くさいのか？</h3>

<p>maven centralにおいてあるライブラリーの品質や、pomなどの情報がバラバラで、一定の品質を保てなかったからのようです。</p>

<p>詳しくはこちらをお読み下さい(英語)。</p>

<ul>
<li><a href="http://www.sonatype.com/people/2010/01/nexus-oss-ecosystem/">Improve The Central Repository and the Supporting the Maven Ecosystem</a></li>
</ul>


<p>central repositoryの品質向上のためにmaven central repoでは下記の規約を儲けています。</p>

<h3>pom.xmlへの要求事項</h3>

<ul>
<li><code>&lt;modelVersion&gt;</code> &ndash; <code>4.0.0</code>を設定する</li>
<li><code>&lt;groupId&gt;</code> &ndash; 申請するときにもgroupIdの申請が必要です。Sonatypeに申請するときはベースになるドメイン名で申請する必要があります。例えば、「<code>org.mikeneck</code>」は大丈夫ですが、「<code>mikeneck</code>」という<strong>groupId</strong>では駄目です。</li>
<li><code>&lt;artifactId&gt;</code> &ndash; ライブラリーの名前ですね。</li>
<li><code>&lt;version&gt;</code> &ndash; バージョン番号です。なお、<code>1.0.0-SNAPSHOT</code>というような<code>SNAPSHOT</code>というバージョンはSonatypeではmaven central repoには乗せてくれませんの、注意して下さい。</li>
<li><code>&lt;packaging&gt;</code> &ndash; 基本的には<code>jar</code>です。</li>
<li><code>&lt;name&gt;</code> &ndash; プロジェクトの名前です。</li>
<li><code>&lt;description&gt;</code> &ndash; ライブラリーに関する情報です。何をしてくれるライブラリーであるかを記述します。</li>
<li><code>&lt;url&gt;</code> &ndash; プロジェクトのurlを設定します。</li>
<li><code>&lt;licenses&gt;</code> &ndash; ライセンスに関する情報を設定します。中には下記の情報が一つ以上入っていることが求められます。</li>
<li><code>&lt;license&gt;&lt;name&gt;</code> &ndash; ライセンス名(ApacheライセンスとかLGPLとか)</li>
<li><code>&lt;license&gt;&lt;url&gt;</code> &ndash; ライセンス条項のurlを記述します</li>
<li><code>&lt;license&gt;&lt;distribution&gt;</code> &ndash; <code>repo</code>を設定します。</li>
<li><code>&lt;scm&gt;&lt;url&gt;</code> &ndash; レポジトリーのurlを記述します。git-hubの場合はsshのアドレス設定します。bitbucketのMercurialの場合はレポジトリーをWebで見る場合のurlを記述します。</li>
<li><code>&lt;scm&gt;&lt;connection&gt;</code> &ndash; git-hubであればsshのところで得られるurlの先頭に<code>scm:git:</code>を加えます。bitbucketのMercurialの場合はWebで見る場合のアドレスの先頭に<code>scm:hg:</code>を付与します。</li>
<li><code>&lt;developers&gt;</code> &ndash; 開発者情報を記入します。その中の構成は次のとおりです。</li>
<li><code>&lt;developer&gt;&lt;id&gt;</code> &ndash; 開発者のID。通名とかでも良いようです。僕の場合は<code>mike_neck</code>を記入します。</li>
<li><code>&lt;developer&gt;&lt;name&gt;</code> &ndash; 開発者の名前です。僕の場合は<code>Shinya Mochida</code>になります。</li>
<li><code>&lt;developer&gt;&lt;email&gt;</code> &ndash; 開発者のメールアドレスです。僕の場合は<code>mike &lt;at&gt; mikeneck.org</code>としています。</li>
</ul>


<h3>配布するファイルへの規約</h3>

<ul>
<li><code>&lt;packaging&gt;</code>が<code>jar</code>の場合にはjarファイルにはjavaクラスが入っていること</li>
<li>名前が<code>projectname-version-javadoc.jar</code>というjavadocのjarが入っていること</li>
<li>名前が<code>projectname-version-sources.jar</code>というソースのjarが入っていること</li>
<li>すべてのartifact(<code>pom.xml</code>、<code>projectname-version.jar</code>、<code>projectname-version-javadoc.jar</code>、<code>projectname-version-sources.jar</code>)に対してPGPによる署名がなされていること</li>
<li>公開鍵が公開鍵サーバーから取得可能になっていること</li>
</ul>


<p>となっています。</p>

<p>また、何らかの理由でjavadocのjarやsourcesのjarが作られない場合でも、READMEというファイルを含んだjavadocのjarよsourcesのjarを作る必要があります。</p>

<h3>gradleでmaven centralにアップロードするためのbuild.gradle</h3>

<p>では、サンプルのbuild.gradleをここに上げておきます。</p>

<p>```groovy build.gradle
[&lsquo;groovy&rsquo;, &lsquo;signing&rsquo;, &lsquo;maven&rsquo;, &lsquo;idea&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// project information
sourceCompatibility = jdkVersion
targetCompatibility = jdkVersion
group = &lsquo;org.jojo.sample&rsquo;
version = &lsquo;1.0&rsquo;
// dependency management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.codehaus.groovy:groovy-all:2.1.3'
testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
</code></pre>

<p>}
// compile options
tasks.withType(Compile) {</p>

<pre><code>options.encoding = 'UTF-8'
</code></pre>

<p>}
// javadoc settings (making template locale en_US)
javadoc {</p>

<pre><code>options.locale = 'en_US'
</code></pre>

<p>}
// creating jars
task sourcesJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
task javadocJar (type : Jar, dependsOn : javadoc) {</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
// collect artifacts to be signed
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign artifacts
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// uploading artifacts
uploadArchives {</p>

<pre><code>repositories.mavenDeployer {
    beforeDeployment {MavenDeployment deployment -&gt;
        signPom(deployment)
    }
    repository (url : sonatypeUrl) {
        authentication (
                userName : sonatypeUsername,
                password : sonatypePassword)
    }
    pom.project {
        name project.name
        packaging 'jar'
        description 'sample project'
        url projectUrl
        licenses {
            license {
                name 'The Apache Software License, Version 2.0'
                url 'http://www.apache.org/license/LICENSE-2.0.txt'
                distribution 'repo'
            }
        }
        scm {
            url githubUrl
            connection "scm:git:${githubUrl}"
            developerConnection "scm:git:${githubUrl}"
        }
        developers {
            developer {
                id 'jojo'
                name 'Jonathan Joester'
                email 'mike &lt;at&gt; mikeneck.org'
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>また、よく使いまわす変数については<code>gradle.properties</code>に書いておきます。</p>

<p><code>bash gradle.properties
jdkVersion=1.7
projectUrl=https://github.com/mike-neck/mike-neck.github.com
github=git@github.com:mike-neck/mike-neck.github.com.git
</code></p>

<p>また、署名関連の変数などについては<code>~/.gradle/gradle.properties</code>に書いておきます。</p>

<p>```bash gradle.properties</p>

<h1>siging information</h1>

<p>signing.keyId=ABCD1234
signing.password=HOGEpassword00
signing.secretKeyRingFile=/Users/username/.gnupg/secring.gpg</p>

<h1>sonatype information</h1>

<p>sonatypeUrl=<a href="https://oss.sonatype.org/service/local/staging/deploy/maven2/">https://oss.sonatype.org/service/local/staging/deploy/maven2/</a>
sonatypeUsername=username
sonatypePassword=password
```</p>

<p>あとは、<code>gradle</code>コマンドで<code>uploadArchives</code>を記述すれば、</p>

<p>Sonatypeの方にアップロードされます。</p>

<p><code>
$ gradle uploadArchives
</code></p>

<p>なお、事前にSonatypeでの<a href="http://goo.gl/XXfRl">JIRAでissueを登録しておくこと</a>や、</p>

<p><a href="http://goo.gl/w9Exz">Nexus UIで最終的なステージング操作</a>をする必要があります。</p>

<p>参考までに、僕が以前作ったissueのリンクを張っておきます。</p>

<p><a href="https://issues.sonatype.org/browse/OSSRH-4119">OSSRH-4119 request for creating repository for Graffiti-mike</a></p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRN0diTW1CSGptaHM"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRN0diTW1CSGptaHM" style="width : 520px;"/></a></p>

<p>中盤終わり</p>

<hr />

<h3>gradleであそぶコーナー</h3>

<p><strong>TBD</strong>と書きたいのですが…</p>

<p>上記の古いgradleでのアーカイブアップロードの方法は、</p>

<p>やや難点があります。</p>

<p>```</p>

<h2>$ gradle tasks</h2>

<h2>All tasks runnable from root project</h2>

<h2>Build tasks</h2>

<p>assemble &ndash; Assembles the outputs of this project.
build &ndash; Assembles and tests this project.
buildDependents &ndash; Assembles and tests this project and all projects that depend on it.
buildNeeded &ndash; Assembles and tests this project and all projects it depends on.
clean &ndash; Deletes the build directory.
jar &ndash; Assembles a jar archive containing the main classes.</p>

<h2>Documentation tasks</h2>

<p>groovydoc &ndash; Generates Groovydoc API documentation for the main source code.
javadoc &ndash; Generates Javadoc API documentation for the main source code.</p>

<h2>Help tasks</h2>

<p>dependencies &ndash; Displays all dependencies declared in root project &lsquo;properties-builder&rsquo;.
dependencyInsight &ndash; Displays the insight into a specific dependency in root project &lsquo;properties-builder&rsquo;.
help &ndash; Displays a help message
projects &ndash; Displays the sub-projects of root project &lsquo;properties-builder&rsquo;.
properties &ndash; Displays the properties of root project &lsquo;properties-builder&rsquo;.
tasks &ndash; Displays the tasks runnable from root project &lsquo;properties-builder&rsquo; (some of the displayed tasks may belong to subprojects).</p>

<h2>IDE tasks</h2>

<p>cleanIdea &ndash; Cleans IDEA project files (IML, IPR)
idea &ndash; Generates IDEA project files (IML, IPR, IWS)</p>

<h2>Upload tasks</h2>

<p>uploadArchives &ndash; Uploads all artifacts belonging to configuration &lsquo;:archives&rsquo;</p>

<h2>Verification tasks</h2>

<p>check &ndash; Runs all checks.
test &ndash; Runs the unit tests.</p>

<h2>Other tasks</h2>

<p>cleanIdeaWorkspace
install &ndash; Installs the &lsquo;archives&rsquo; artifacts into the local Maven repository.
wrapper</p>

<h2>Rules</h2>

<p>Pattern: build<ConfigurationName>: Assembles the artifacts of a configuration.
Pattern: upload<ConfigurationName>: Assembles and uploads the artifacts belonging to a configuration.
Pattern: clean<TaskName>: Cleans the output files of a task.</p>

<p>To see all tasks and more detail, run with &mdash;all.</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 10.478 secs
```</p>

<p>uploadArchivesのところを見ると、</p>

<p><code>archives</code> configurationに登録されているすべてのartifactsをアップロードする</p>

<p>と書かれています。</p>

<p>ただ、これだと、ひとつのアップロードしか書いていくことができないので、</p>

<p>非常に面倒です。</p>

<p>たとえば、こういった局面があります。</p>

<ul>
<li>in-houseリポジトリーにも登録する</li>
<li>maven centralにも登録する</li>
<li>異なるartifactsをアップロードする</li>
<li>dependenciesにトリッキーなことをしているので、dependenciesの記述を書き換えたい</li>
</ul>


<p>こういったケースでは、</p>

<p>一つ一つ別々のタスクとして記述をしていかないとできない場合があります。</p>

<p>gradleは柔軟性も求めるツールなので、</p>

<p>これらの要望も吸収して</p>

<p>簡単な記述でできるように常に進化を遂げています。</p>

<p>それを満たす機能が、今回のテーマの<strong>maven-publish</strong>プラグインです。</p>

<p><strong>maven-publish</strong>プラグインでは<code>archives</code> configuration以外の成果物も</p>

<p>柔軟に発行できますし、依存性を書き換えることもできます。</p>

<p>記述はこんな感じになります。</p>

<p>```groovy build.gradle
[&lsquo;groovy&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// 中略
publishing {</p>

<pre><code>publications {
    ourMavenServer(MavenPublication) {
        from components.java
        artifact sourceJar
        pom.withXml {
            def node = asNode()
            node.removeNode(node.dependencies[0])
            asNode().children().last() + {
                resolveStrategy = CLosure.DELEGATE_FIRST
                // writing additional pom elements with builder style
                name 'our-subproject'
                description 'our-subproject description'
                url 'https://www.google.com'
            }
            // overwrite dependencies
            asNode().dependencies[0].replaceNode {
                resolveStrategy = Closure.DELEGATE_FIRST
                dependencies {
                    def dep = project.configurations.another.dependencies
                    dep.each {d -&gt;
                        dependency {
                            groupId d.group
                            artifactId d.name
                            version d.version
                            scope 'compile'
                        }
                    }
                }
            }
        }
    }
}
repositories {
    maven {
        name 'in-house'
        url 'https://repos.mycompany.com/nexus/service/local/staging/deploy/maven2/'
    }
}
</code></pre>

<p>}
```</p>

<p>上記の例でやっていることは</p>

<ul>
<li>ドキュメント読まないのでclassesとsourcesだけをアーカイブ化</li>
<li>ちろっとpom.xmlに情報を追加</li>
<li>dependenciesを書き換え</li>
</ul>


<p>一般常識的に考えれば、dependenciesの書き換えはマズイと思われますが…</p>

<p>某有名なライブラリーのpom.xmlでありもしないartifactを参照しているライブラリーがあり、</p>

<p><code>compile</code> configurationではプロジェクトのdependencyを指定するのではなく、</p>

<p>```
configurations {</p>

<pre><code>another
</code></pre>

<p>}
```</p>

<p>と異なるconfigurationを設定して、</p>

<p>プロジェクトのdependencyを設定する場合などがあります。</p>

<p>某有名ライブラリーとは<strong>org.eclipse.jetty:jetty-server</strong>というんですけどね…</p>

<hr />

<p>さて、もう少し遊んでいるんですが、</p>

<p>それは別の記事にしますね。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
</feed>
