<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gradle | mike、mikeなるままに…]]></title>
  <link href="http://mike-neck.github.io/blog/categories/gradle/atom.xml" rel="self"/>
  <link href="http://mike-neck.github.io/"/>
  <updated>2013-06-21T10:31:59+09:00</updated>
  <id>http://mike-neck.github.io/</id>
  <author>
    <name><![CDATA[mike-neck]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gradleのmaven-publishプラグインでライブラリーを発行する方法 - 1]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1/"/>
    <updated>2013-06-19T16:21:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/19/publish-maven-artifact-with-sign-files-1</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>ここ数日、gradleのmaven-publishプラグインにはまっていたので、</p>

<p>そのメモです。</p>

<p>なお、例によって長い記事なので、完成されたbuild.gradleだけ見たい方は、いっちばん下に行って下さい。</p>

<p>ただし、完成されたbuild.gradle読んでも理解できないと思いますけどね。</p>

<h1>maven-publishプラグインについて</h1>

<p>以下のとおりにメモしていきます。</p>

<ul>
<li>maven-publishプラグインの基礎</li>
<li>javadoc、sourcesを発行する</li>
<li>複数回、成果物を発行する</li>
<li>pomを変更する</li>
<li>PGP署名ファイルの発行</li>
<li>課題</li>
</ul>


<h2>maven-publishプラグインの基礎</h2>

<p>maven-publishプラグインは任意のファイルを</p>

<p>任意のmavenレポジトリーにアップロードすることができるプラグインです。</p>

<p>次のようなビルドスクリプトでは、以下のようなartifactを発行することができます。</p>

<ul>
<li>sample-project-1.0.jar</li>
<li>sample-project-1.0.pom</li>
<li>sample-project-1.0-doc.html</li>
</ul>


<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>また、これらに付随して、それぞれのファイルのmd5ファイルとsha1ファイルも作成されます。</p>

<p>実際に実行してみます。</p>

<p>```
$ gradle clean test publish
:clean UP-TO-DATE
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo
Transferring 0K from remote
Uploaded 0K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 18.255 secs
```</p>

<p>pomファイルが発行されたのかどうかよくわかりませんが、</p>

<p>実際に発行されたディレクトリーを見てみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample
$ ls
sample-project
$ cd sample-project/
$ ls
1.0    maven-metadata.xml    maven-metadata.xml.md5    maven-metadata.xml.sha1
$ cd 1.0/
$ ls
sample-project-1.0-doc.html      sample-project-1.0.jar      sample-project-1.0.pom
sample-project-1.0-doc.html.md5  sample-project-1.0.jar.md5  sample-project-1.0.pom.md5
sample-project-1.0-doc.html.sha1 sample-project-1.0.jar.sha1 sample-project-1.0.pom.sha1
</code></p>

<p>ということでコマンドを実行したあとの標準出力にはpomについての記述はありませんが、</p>

<p>ちゃんと発行されています。</p>

<h3>規約</h3>

<p>maven-publishプラグインでは以下のようなルールがあります。</p>

<ul>
<li>基本的なartifact名はproject名(ディレクトリの名前) + version番号</li>
<li><code>classifier</code>に指定された文字列は上記のファイル名の最後に付与される</li>
<li><code>extension</code>で指定された文字列は拡張子として付与される</li>
<li><code>classifier</code> + <code>extension</code>での一意性のチェックが行われる</li>
</ul>


<h2>javadoc、sourcesを発行する</h2>

<p>では、先ほどのサンプルに、ソースとjavadocを付与してみます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>DSLによれば、メソッド<code>artifact</code>にはtaskを引数にとることができ、指定したtaskの成果物を発行することができます。</p>

<p>上記の例では、<code>sourceJar</code>タスクによってjarファイルに固められたソースと、</p>

<p><code>javadocJar</code>タスクに寄ってjarファイルに固められたjavadocが、</p>

<p>発行されるようになります。</p>

<p>では、実行してみましょう。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForSamplePublication
:jar
:javadoc
:javadocJar
:sourceJar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 25.84 secs
```</p>

<p>上記の標準出力からソースとjavadocが出力されていることがわかります。</p>

<p>実際に出力されたファイルを確認してみます。</p>

<p><code>
$ cd /Users/mike/maven-sample-repo/org/mikeneck/sample/sample-project/1.0
$ ls -la
total 184
drwxr-xr-x  17 mike  mike   578B  6 19 17:40 .
drwxr-xr-x   6 mike  mike   204B  6 19 17:05 ..
-rw-r--r--   1 mike  mike   346B  6 19 17:40 sample-project-1.0-doc.html
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-doc.html.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-doc.html.sha1
-rw-r--r--   1 mike  mike    33K  6 19 17:40 sample-project-1.0-javadoc.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-javadoc.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-javadoc.jar.sha1
-rw-r--r--   1 mike  mike   927B  6 19 17:40 sample-project-1.0-sources.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0-sources.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0-sources.jar.sha1
-rw-r--r--   1 mike  mike   1.1K  6 19 17:40 sample-project-1.0.jar
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.jar.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.jar.sha1
-rw-r--r--   1 mike  mike   404B  6 19 17:40 sample-project-1.0.pom
-rw-r--r--   1 mike  mike    32B  6 19 17:40 sample-project-1.0.pom.md5
-rw-r--r--   1 mike  mike    40B  6 19 17:40 sample-project-1.0.pom.sha1
</code></p>

<h2>複数回、成果物を発行する</h2>

<p>これまでの例では<code>sample</code>という発行タスクにいろいろなものを詰め込んでいました。</p>

<p>たとえば、javadocだけとか、sourcesファイルだけとか発行したい場合、</p>

<p>成果物の発行タスクを切り分けたいような場面があるかと思います。</p>

<p>その場合、<code>publications</code>の下の記述を変えることで、成果物の発行タスクを分けることができます。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    // only java archives
    sample(MavenPublication) {
        from components.java
    }
    // publish documents
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>これで、メインのjarを発行するタスクと、</p>

<p>ドキュメント類を発行するタスクを切り分けることができました。</p>

<p>実際、タスクにはどのようなものがあるか確認します。</p>

<p>```
$ gradle tasks
:tasks</p>

<hr />

<h2>All tasks runnable from root project</h2>

<h2>Build tasks</h2>

<p>assemble &ndash; Assembles the outputs of this project.
build &ndash; Assembles and tests this project.</p>

<p>…中略…</p>

<h2>Publishing tasks</h2>

<p>publish &ndash; Publishes all publications produced by this project.
publishDocumentsPublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;documents&rsquo; to the local Maven repository.
publishDocumentsPublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;documents&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishSamplePublicationToMavenLocal &ndash; Publishes Maven publication &lsquo;sample&rsquo; to the local Maven repository.
publishSamplePublicationToMavenRepository &ndash; Publishes Maven publication &lsquo;sample&rsquo; to Maven repository &lsquo;maven&rsquo;.
publishToMavenLocal &ndash; Publishes all Maven publications produced by this project to the local Maven cache.</p>

<p>…中略…</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.853 secs
```</p>

<p>Publishing tasksには次のようなエントリーが入っています。</p>

<ul>
<li><code>publish</code> すべてを指定したレポジトリーに発行する</li>
<li><code>publicDocumentsPublication…</code> <code>documents</code>で指定したアーカイブを発行します。</li>
<li><code>publishSamplePublication…</code> <code>sample</code>で指定したアーカイブを発行します。</li>
<li><code>publishToMavenLocal</code> すべてをmaven localレポジトリーに発行します。</li>
</ul>


<p>という形で、<code>publishing/publications</code>で複数のアーカイブ発行を指定することで、タスクが生成されます。</p>

<p>さて、ここでは、<code>publish</code>タスクを実行してみたいと思います。</p>

<p>```
$ gradle clean test publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test
:generatePomFileForDocumentsPublication
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForSamplePublication
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 12.33 secs
```</p>

<p>標準出力を見るとわかりますが、<strong>アルファベット順</strong>にタスクが実行されます。</p>

<p>そして、もう一つ気になるところがありますね。</p>

<p>各タスクの前に、<code>generatePomFileFor[タスク名]</code>というタスクが実行されています。</p>

<p>これらが発行するpomは何かを調べてみます。</p>

<p>まず、すこしスクリプトを変更します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p><code>dependencies</code>を追加しました。</p>

<p>この状態で、sampleの方を実行してみます。</p>

<blockquote><p>なお、このタスクの実行において、タスクの指定に省略名を使用しています。</p>

<p>gradleでは<code>publishToMavenRepository</code>のような単語の頭文字が大文字になっているタスクを</p>

<p>頭文字だけを選択して<code>pTMR</code>のように省略することができます。</p></blockquote>

<p>```
$ gradle clean pSPTMR
:clean
:generatePomFileForSamplePublication
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:publishSamplePublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 2.498 secs
```</p>

<p>さて、この結果出力されたpomは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
</project>
```</p>

<p>一方、documentの方を実行してみます。</p>

<p>```
$ gradle clean pDPTMR
:clean
:generatePomFileForDocumentsPublication
:compileJava
:processResources UP-TO-DATE
:classes
:javadoc
:javadocJar
:sourceJar
:publishDocumentsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-doc.html to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 33K from remote
Uploaded 33K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 4.961 secs
```</p>

<p>この結果出力されたpomは次のとおり、<code>&lt;dependencies&gt;</code>〜<code>&lt;/dependencies&gt;</code>の部分の記述がなくなります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;project xsi:schemaLocation=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>&rdquo; xmlns=&ldquo;<a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a>&rdquo;</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
</code></pre>

<p>  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
</project>
```</p>

<p>この違いは、前者のタスクにおいてdependenciesの情報を利用するのに対して、</p>

<p>後者はdependenciesを使わないことにあると勝手に理解しています。</p>

<p>したがって、複数回にわたって成果物を発行する場合は、</p>

<p>pomの生成について気をつけなければなりません。</p>

<h2>pomを変更する</h2>

<p>前回のポストで記述した通り、maven centralに登録するライブラリーについては、</p>

<p>発行するpomにいくつか追加情報を与えなければならない場合があります。</p>

<p>また、Jettyのservletを用いる場合は、</p>

<p>jetty-orbitという存在しないartifactを避けるために、</p>

<p>直接dependencyを書けない場合などがあります。</p>

<p>そのような場合に、pomを書き換える必要が生じます。</p>

<h3>publicationコンテナのpomオブジェクトを用いる</h3>

<p>maven-publishプラグインではpublicationコンテナにて</p>

<p>pomオブジェクトを介して発行されるpomにアクセスすることができます。</p>

<p>先ほどのビルドスクリプトにpomを生成するタスクを追加します。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;
apply plugin : &lsquo;maven-publish&rsquo;
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repositories
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependencies
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
</code></pre>

<p>}
// zip javadocs
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
</code></pre>

<p>}
// publishing description
publishing {</p>

<pre><code>publications {
    sample(MavenPublication) {
        from components.java
    }
    documents(MavenPublication) {
        artifact ('document.html') {
            classifier = 'doc'
            extension  = 'html'
        }
        artifact sourceJar {
            classifier = 'sources'
            extension  = 'jar'
        }
        artifact javadocJar {
            classifier = 'javadoc'
            extension  = 'jar'
        }
    }
    // editing pom file with builder style
    pomOnly(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
        }
    }
}
repositories {
    maven {
        url 'file://Users/mike/maven-sample-repo'
    }
}
</code></pre>

<p>}
```</p>

<p>pomオブジェクトの<code>withXml</code>メソッドの引数の<code>Closure</code>は、</p>

<p><code>org.gradle.api.XmlProvider</code>のメソッドを呼び出すことができます。</p>

<p>そして、<code>asNode()</code>メソッドによりpomファイルを<code>groovy.util.Node</code>の形で取得出来ます。</p>

<p><code>asNode()</code>で返ってくる<code>Node</code>の一番トップの部分は<code>&lt;project&gt;</code>要素です。</p>

<p>この要素の子要素を取得し、最後の要素に<code>plus</code>メソッドで要素を追加します。</p>

<p>追加する<code>Closure</code>は、<code>groovy.util.NodeBuilder</code>と同等のDSLによって、</p>

<p>pomに要素を追加していくことができます。</p>

<p>では、このタスクを実行してみます。</p>

<p>```
$ gradle clean pPOPTMR
:clean
:generatePomFileForPomOnlyPublication
:publishPomOnlyPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/maven-sample-repo/
Transferring 1K from remote
Uploaded 1K</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 5.813 secs
```</p>

<p>発行されたpomファイルは次のようになります。</p>

<p>```xml sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <packaging>pom</packaging>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<h2>PGP署名ファイルの発行 &mdash; 書きかけ…</h2>

<p>少し話題が飛びますが、</p>

<p>maven central repositoryにライブラリーを発行する場合、</p>

<p>各アーカイブファイルとpomファイルに対してPGP(Pretty Good Privacy)署名が必要となります。</p>

<h3>PGP署名って…？</h3>

<p>PGP署名を簡単に説明すると以下のようになります。</p>

<ul>
<li>配布物を元に、配布元で非公開鍵で暗号化して署名を作る</li>
<li>受け取り側で署名に対して公開鍵で復号化したものと、配布物とを比較する</li>
<li>一致していれば配布物が正しいもの(改ざんされていない)と判定される</li>
</ul>


<p>というファイルの信頼性を確認する仕組みです。</p>

<p>なお、PGPツールとしては、PGPの仕様RFC4880に準拠した、</p>

<p><a href="http://www.gnupg.org">GnuPG(Gnu Privacy Guard)</a>を使うのが一般的なようです。</p>

<p>なお、GnuPGの現在のバージョンは2.0です。</p>

<p>また、Javaでの実装ではBCPGが有名です。</p>

<p>また、gradle本題も<code>bcpg-jdk15-1.46</code>を利用しています。</p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRNzktQnBvNjBnZE0" style="width : 300px;"/></a></p>

<h3>署名タスクを作成する</h3>

<p>mavenプラグイン + signプラグインであれば、以下の様な記述で署名を作成することが可能です。</p>

<p>```groovy build.gradle
[&lsquo;maven&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
artifacts {</p>

<pre><code>archives jar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、maven-publishプラグインでは、明示的に署名ファイルも取り扱いたいので、</p>

<p>一工夫が必要になります。</p>

<p>```groovy build.gradle
// plugins see(1)
[&lsquo;maven-publish&rsquo;, &lsquo;signing&rsquo;].each {apply plugin : it}
// zip sources. see(4)
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
// zip javadocs. see(4)
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
// add classifier to jar file
classifier = 'javadoc'
</code></pre>

<p>}
// collect artifacts. see(3)
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign task. see(2)
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// execute sign task. see(7)
task preparePublication (dependsOn : signArchives)
// extracting signature files with classifier and extension. see(5)
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publishing artifacts
    jars(MavenPublication) {
        from components.java
        [
                [jarTask : tasks.sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : tasks.javadocJar, classifier : 'javadoc', extension : 'jar']                    
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.classifier
            }
        }
    }
    // publishing signature files. see(6)
    jarSignatures (MavenPublication) {
        getSignatureFiles().each {signedArchive -&gt;
            artifact (signedArchive.archive) {
                classifier = signedArchive.classifier
                extension  = signedArchive.extension
            }
        }
    }
    // publishing pom file
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                name 'sample-project'
                description 'give information of gradle maven-publish plugin'
                url projectUrl
                dependencies {
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
                scm {
                    url github
                    connection scmUrl
                    developerConnection developerUrl
                }
                developers {
                    developer {
                        id 'mike_neck'
                        name 'Shinya Mochida'
                        email 'mike &lt;at&gt; mikeneck.org'
                    }
                }
            }
        }
    }
}
repositories {
    fladDirs "${project.projectDirs}/artifacts"
}
</code></pre>

<p>}
```</p>

<p>変更点は次のとおりです。</p>

<h4>(1) signingプラグインを導入します。</h4>

<p>signingプラグインではmavenプラグインと連携して次のように署名を作成することができます。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
```</p>

<p>しかし、mavenプラグインを使わないので、上記の方法では望みの署名ファイルを取得出来ません。</p>

<h4>(2) <code>Sign</code>タイプのタスクを作成する</h4>

<p>signingプラグインが入っているので、<code>type</code>が<code>Sign</code>のタスクを定義することができます。</p>

<p>このタスクを作成しておくと、指定したファイルに対して署名を作成することができます。</p>

<p>なお、このタスクは事前に署名対象のファイルがあることが前提なので、</p>

<p><code>jar</code>、<code>javadocJar</code>、<code>sourceJar</code>タスクに依存しています。</p>

<h4>(3) 成果物を一つの変数でアクセスできるようにする</h4>

<p><code>artifacts{}</code>ブロックでは指定した<code>configuration</code>に成果物を登録することができます。</p>

<p>次の例では<code>archives</code> configurationにjarタスク、javadocJarタスク、sourceJarタスクの成果を</p>

<p>登録します。</p>

<p>```groovy build.gradle
artifacts {</p>

<pre><code>archives jar
archives javadocJar
archives sourceJar
</code></pre>

<p>}
```</p>

<p>これによって、<code>configurations.archives</code>というプロパティから、</p>

<p>各種タスクの成果物にアクセスできるようになります。</p>

<h4>(4) <code>Jar</code>タイプのタスクにclassifierを指定して、成果物のファイル名を修正します。</h4>

<p>```groovy build.gradle
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
// add classifier to jar file
classifier = 'sources'
</code></pre>

<p>}
```</p>

<p>これによって、作成されるsourcesJarのファイル名に<code>-sources</code>が含まれるようになります。</p>

<h4>(5) 署名ファイルを取り出します</h4>

<p><code>type</code>が<code>Sign</code>のタスクの<code>getSignatureFiles()</code>メソッドは、署名したファイルのリストを返します。</p>

<p>それらを<code>classifier</code>によって、わけて取り出して、</p>

<p>改めて<code>classifier</code>と<code>extension</code>を付与します。</p>

<h4>(6) 署名ファイルをそれぞれ発行します。</h4>

<p>上記の(5)のクロージャー<code>getSignatureFiles</code>によって、</p>

<p>署名ファイルと<code>classifier</code>と<code>extension</code>を取得し、</p>

<p>それぞれartifactとして登録、発行します。</p>

<h4>(7) 事前に実行しておくタスクをまとめたタスクを追加</h4>

<p>署名ファイルを作成するタスクを確実に実行しておくために、</p>

<p><code>preparePublication</code>タスクを作成します。</p>

<p>これを<code>publish</code>タスクの前に実行します。</p>

<hr />

<p>それでは<code>publish</code>タスクを実行してみます。</p>

<p>```
$gradle clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 10.894 secs
```</p>

<p>さて、署名ファイルが作成されているか確認します。</p>

<p><code>
$ cd /Users/mike/IdeaProjects/sample-project/artifacts/org/mikeneck/sample/sample-project/1.0
$ ls | grep asc
sample-project-1.0-javadoc.jar.asc
sample-project-1.0-javadoc.jar.asc.md5
sample-project-1.0-javadoc.jar.asc.sha1
sample-project-1.0-sources.jar.asc
sample-project-1.0-sources.jar.asc.md5
sample-project-1.0-sources.jar.asc.sha1
sample-project-1.0.jar.asc
sample-project-1.0.jar.asc.md5
sample-project-1.0.jar.asc.sha1
</code></p>

<p>それぞれ署名ファイルが作成されているようです。</p>

<p>では、署名ファイルを検証してみましょう。</p>

<p><code>
$ gpg2 --verify sample-project-1.0-javadoc.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0-sources.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
$ gpg2 --verify sample-project-1.0.jar.asc
gpg: Signature made 木  6/20 18:05:08 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>ちゃんと署名できていることが確認できました。</p>

<h2>課題</h2>

<p>さて、jarファイルの署名をすることは出来ました。</p>

<h4>pom署名ファイル問題</h4>

<p>しかし、残念なことにpomファイルの署名ができていません。</p>

<p>上述のpomファイルを変更するというところで記述した</p>

<p><code>org.gradle.api.XmlProvider</code>の実装クラスは</p>

<p><code>org.gradle.api.internal.xml.XmlTransformer.XmlProviderImpl</code>です。</p>

<p>そのクラスには<code>public void writeTo(java.io.File file)</code>というメソッドがあります。</p>

<p>そのメソッドを介してpomファイルを出力することが可能です。</p>

<p>したがって、次の手順でpomファイルの署名も発行することが可能ではないかと</p>

<p>考えられます。</p>

<ol>
<li>pom出力タスク中でpomファイルを書き出し</li>
<li>pom出力タスク中で書きだしたpomファイルの署名をするタスクを実行</li>
<li>pomファイルの署名をするタスクから署名ファイルを取得</li>
<li>署名ファイルをartifactとして発行</li>
</ol>


<p>上記の手順を実行するようにビルドスクリプトを書いてみます。</p>

<p>以下、一部抜粋。</p>

<p>```groovy build.gradle
// pom file
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// task for signing pom
task signPom(type : Sign) {</p>

<pre><code>sign pomFile
</code></pre>

<p>}
// getting a signature of pom
def getPomSignatrure = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // publish pom
    pom(MavenPublication) {
        pom.withXml {
            def node = asNode()
            node.chidren().last() + {
                dependencies {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    project.configurations.compile.dependencies.each {dep -&gt;
                        dependency {
                            groupId dep.group
                            artifactId dep.name
                            version dep.version
                        }
                    }
                }
            }
            writeTo(project.ext.pomFile)
            project.tasks.signPom.execute()
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>ではpublishタスクを実行してみます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarsPublication
:publishJarsPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:generatePomFileForPomPublication
:publishPomPublicationToMavenRepository FAILED</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>What went wrong:
Execution failed for task &lsquo;:publishPomPublicationToMavenRepository&rsquo;.</p>

<blockquote><p>Failed to publish publication &lsquo;pom&rsquo; to repository &lsquo;maven&rsquo;
Invalid publication &lsquo;pom&rsquo;: artifact file does not exist: &lsquo;/Users/mike/IdeaProjects/sample-project/tmp/pom.xml.asc&rsquo;</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 5.357 secs
```</p>

<p><code>publishPomPublicationToMavenRepository</code>タスクで落ちてしまっています。</p>

<p>理由は署名ファイルが見つからないということです。</p>

<p>では、該当のディレクトリーの中身を見てみます。</p>

<p><code>
$ ls temp
pom.xml
</code></p>

<p>pomファイルだけしか出力されていません。</p>

<p>したがって、署名タスクが実行できてない状態になっているわけです。</p>

<p>実行されたタスクを挙げてみると、このようになっています。</p>

<ul>
<li>:clean</li>
<li>:compileJava</li>
<li>:processResources UP-TO-DATE</li>
<li>:classes</li>
<li>:jar</li>
<li>:javadoc</li>
<li>:javadocJar</li>
<li>:sourceJar</li>
<li>:signArchives</li>
<li>:preparePublication</li>
<li>:generatePomFileForJarSignaturesPublication</li>
<li>:publishJarSignaturesPublicationToMavenRepository</li>
<li>:generatePomFileForJarsPublication</li>
<li>:publishJarsPublicationToMavenRepository</li>
<li>:generatePomFileForPomPublication</li>
<li>:publishPomPublicationToMavenRepository FAILED</li>
</ul>


<p>よくみてみると、signPomタスクは実行されていません。</p>

<p>というわけで、明示的にsignPomタスクを実行する必要があるわけですが、</p>

<p>(<code>Task#execute()</code>で呼び出さないということ)</p>

<p><code>Task#dependsOn</code>でsignPomタスクを指定しても、発行できないだけでなく、</p>

<p>実際にはpublishing-publicationのコンテキストでは<code>dependsOn</code>が使えません。</p>

<p>先ほどのビルドスクリプトを一部変更してみます。</p>

<p>```groovy build.gradle
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            writeTo(project.ext.pomFile)
        }
        artifact (getPomSignature()) {
            classifier = null
            extension  = 'pom.asc'
        }
    }
}
</code></pre>

<p>}
```</p>

<p>このビルドスクリプトをパースさせると次のようなエラーが発生します。</p>

<p>```
$ gradle tasks
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>Where:
Build file &lsquo;/Users/mike/IdeaProjects/sample-project/build.gradle&rsquo; line: 90</p></li>
<li><p>What went wrong:
A problem occurred configuring root project &lsquo;sample-project&rsquo;.</p>

<blockquote><p>Cannot create a Publication named &lsquo;dependsOn&rsquo; because this container does not support creating elements by name alone. Please specify which subtype of Publication to create. Known subtypes are: MavenPublication</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 13.805 secs
```</p>

<p>たとえ、これがDSL上問題がなくても、</p>

<p>pomファイルの出力はsignPomタスクの後に実行されるので、</p>

<p>エラーが発生することは予見できます。</p>

<h4>現状考えられるpom署名ファイル回避方法</h4>

<p>gradleではダイナミックにタスクの定義ができます。</p>

<p>これを利用して、pomファイルがない場合は、</p>

<p>pomファイルの生成を行い、</p>

<p>一時的なファイルに対して発行を行います。</p>

<p>そして、pomファイルが存在する場合には、</p>

<p>署名タスクを実行して、</p>

<p>artifact登録して、maven repositoryへ発行します。</p>

<p>整理すると…</p>

<ul>
<li>maven publishプラグインを二回実行する。</li>
<li>pomファイルが存在しない場合は、signPomを実行しない、<code>withXml</code>で<code>writeTo</code>を使ってpomファイルを出力する。</li>
<li>pomファイルが存在する場合は、signPomを先に実行しておいて、署名ファイルもartifactとして発行する</li>
</ul>


<p>ということになります。</p>

<p>ビルドスクリプトを以下に示します(該当部分のみ)。</p>

<p>```groovy build.gradle
// dynamic definition of preparePublication
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// publishing if pomFile exists
publishing {</p>

<pre><code>publications {
    // 中略
    pom(MavenPublication) {
        dependsOn project.tasks.signPom
        pom.withXml {
            // 中略
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
        if (project.ext.pomFile.exists()) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        } else {
            delete(project.ext.pomFile)
        }
    }
}
</code></pre>

<p>}
```</p>

<p>…で、これは実は失敗しました。</p>

<p>ヒントは、発行されるpomの<code>&lt;packaging&gt;&lt;/packaging&gt;</code>にあります。</p>

<ul>
<li>jarSignaturesタスクの場合は<code>&lt;packaging&gt;jar.asc&lt;/packaging&gt;</code></li>
<li>jarsタスクの場合は<code>&lt;packaging&gt;&lt;/packaging&gt;</code>要素なし</li>
<li>pomタスクの場合はpomFileが存在する場合は<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>、pomFileが存在しない場合は<code>&lt;packaging&gt;</code>要素なし</li>
</ul>


<p>となります。</p>

<p>pomFileが存在する場合に署名タスクを実行するという戦略をとっていたわけですが、</p>

<p>signPomタスクはpomFileが存在しない場合のpomファイル、</p>

<p>つまり<code>&lt;packaging&gt;</code>要素なしのものを元に署名を行うため、</p>

<p>同時に発行されるpomファイルが<code>&lt;packaging&gt;pom.asc&lt;/packaging&gt;</code>を持ってしまうために、</p>

<p>署名ファイルが不適切なものになってしまうという不具合が発生してしまいました。</p>

<h4>改めてpomファイルの発行と、署名タスクの戦略を考えなおす</h4>

<h5>projectのメインのpom出力について</h5>

<p>先ほどの<code>&lt;packaging&gt;</code>要素に関しては、</p>

<p><code>groovy build.gradle
def node = = asNode()
def packagingNode = node.children().find{it.name().localPart.contains('packaging')}
node.remove(packageingNode)
</code></p>

<p>とやっても、発行されるartifactの<code>extension</code>によって、<code>&lt;packaging&gt;</code>要素が追加されてしまいます。</p>

<p>したがって、pomファイルの修正はjarファイルの発行タスクと同時に実施するのが望ましい形であると言えます。</p>

<p>なぜならば、jarファイルの発行タスクではすべての<code>extension</code>が<code>jar</code>であるため、</p>

<p>適切なpomファイルが作成されうるためです。</p>

<p>また、これはpomの署名ファイルの発行の元になるために、</p>

<p>ここでpomファイルの書き出しをしておく必要があります。</p>

<h5>署名ファイルの生成について</h5>

<p>pomファイルが存在している場合にのみ、署名タスクを実行、</p>

<p>署名ファイルアップロードするタスクが実行できるようにします。</p>

<h5>タスクの実行順について</h5>

<p>前述のとおり、pomファイルは後から実行されるタスクで上書きされていくので、</p>

<p>jarが発行されるタスクが一番最後に実施されるようにする必要があります。</p>

<p>その他の署名ファイルの発行タスクは、その先に実行されるようにします。</p>

<h4>以上の戦略に基づいたビルドスクリプト</h4>

<p>実行順序などに気をつけてビルドスクリプトを更新しました。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>publish タスクは二度実行します。</p>

<p>一度目はpomファイルを生成するだけが目的です。</p>

<p>二度目はpomの署名も生成して、すべてをmaven repositoryにアップロードします。</p>

<h4>一度目のpublishタスク実行結果</h4>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:preparePublication
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/tmp/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 21.149 secs
```</p>

<p>これは、あくまでpomファイルの生成を目的にしたpublish タスクです。</p>

<p>念の為にpomファイルを確認しておきます。</p>

<p>```
$ cat tmp/pom.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>これが次に実行するpublishタスクにて署名されてmaven repositoryにアップロードされます。</p>

<p>```
$ gradle &mdash;daemon clean pP publish
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:jar
:javadoc
:javadocJar
:sourceJar
:signArchives
:signPom UP-TO-DATE
:preparePublication
:generatePomFileForGpg-pomPublication
:publishGpg-pomPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.pom.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForJarSignaturesPublication
:publishJarSignaturesPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar.asc to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 0K from remote
Uploaded 0K
:generatePomFileForMainJarPublication
:publishMainJarPublicationToMavenRepository
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-sources.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 1K from remote
Uploaded 1K
Uploading: org/mikeneck/sample/sample-project/1.0/sample-project-1.0-javadoc.jar to repository remote at file:/Users/mike/IdeaProjects/sample-project/artifacts/
Transferring 33K from remote
Uploaded 33K
:publish</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 8.249 secs
```</p>

<p>pom.ascファイルが無事発行されたようです。</p>

<p>それでは、適切なファイルであるかどうか、検証します。</p>

<p><code>
$ cd artifacts/org/mikeneck/sample/sample-project/1.0/
$ gpg2 --verify sample-project-1.0.pom.asc
gpg: Signature made 金  6/21 04:56:06 2013 JST using RSA key ID ABC12345
gpg: Good signature from "Shinya Mochida (Groovy/JavaScript Developer in Japan) &lt;mike@mikeneck.org&gt;"
</code></p>

<p>適切なファイルであることが検証できたようです。</p>

<p>また、pomファイルの<code>&lt;packaging&gt;</code>の部分がちゃんと<code>jar</code>になっているか</p>

<p>確認しておきます。</p>

<p>```
$ cat sample-project-1.0.pom
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.mikeneck.sample</groupId>
  <artifactId>sample-project</artifactId>
  <version>1.0</version>
  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;
  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;
  &lt;version&gt;1.6.3&lt;/version&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>  </dependencies>
  <packaging>jar</packaging>
  <licenses></p>

<pre><code>&lt;license&gt;
  &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;
  &lt;url&gt;http://www.apache.org/license/LICENSE-2.0.txt&lt;/url&gt;
  &lt;distribution&gt;repo&lt;/distribution&gt;
&lt;/license&gt;
</code></pre>

<p>  </licenses>
</project>
```</p>

<p>ちゃんと<code>jar</code>になっているようなので、</p>

<p>全体的に成功であると判断出来ます。</p>

<h2>結論</h2>

<p>完成されたbuild.gradleファイルを再掲します。</p>

<p>```groovy build.gradle
// declaration of plugins
[&lsquo;java&rsquo;, &lsquo;maven-publish&rsquo;, &lsquo;idea&rsquo;, &lsquo;signing&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// dynamic properties
ext {</p>

<pre><code>pomFilePath = "${project.projectDir}/tmp/pom.xml"
pomFile = file(pomFilePath)
</code></pre>

<p>}
// project information
group = &lsquo;org.mikeneck.sample&rsquo;
version = &lsquo;1.0&rsquo;
// repository management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
// dependency management
dependencies {</p>

<pre><code>compile 'org.jsoup:jsoup:1.6.3'
testCompile 'junit:junit:4.11'
</code></pre>

<p>}
// zip sources
task sourceJar(type : Jar) {</p>

<pre><code>from sourceSets.main.allJava
classifier = 'sources'
</code></pre>

<p>}
// zip javadoc
task javadocJar(type : Jar, dependsOn : javadoc) {</p>

<pre><code>from javadoc.destinationDir
classifier = 'javadoc'
</code></pre>

<p>}
// configuration for pom signing
configurations {</p>

<pre><code>pom
</code></pre>

<p>}
// extract artifacts for publishing signatures
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
if (pomFile.exists()) {
    pom pomFile
}
</code></pre>

<p>}
// jar signin
task signArchives (type : Sign, dependsOn : [jar, sourceJar, javadocJar]) {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// getting signature files
def getSignatureFiles = {</p>

<pre><code>def allFiles = tasks.signArchives.signatureFiles.collect{it}
def signedSources = allFiles.find { it.name.contains('-sources') }
def signedJavadoc = allFiles.find { it.name.contains('-javadoc') }
def signedJar = (allFiles - [signedSources, signedJavadoc])[0]
return [
        [archive: signedSources, classifier: 'sources', extension: 'jar.asc'],
        [archive: signedJavadoc, classifier: 'javadoc', extension: 'jar.asc'],
        [archive: signedJar,     classifier: null,      extension: 'jar.asc']
]
</code></pre>

<p>}
// signing pom file
task signPom(type : Sign) {</p>

<pre><code>sign configurations.pom
</code></pre>

<p>}
// prepare publication tasks depends on existence of pom file
if (pomFile.exists()) {</p>

<pre><code>task preparePublication (dependsOn : [signArchives, signPom])
</code></pre>

<p>} else {</p>

<pre><code>task preparePublication (dependsOn : signArchives)
</code></pre>

<p>}
// getting pom signature
def getPomSignature = {</p>

<pre><code>return project.tasks.signPom.signatureFiles.collect{it}[0]
</code></pre>

<p>}
publishing {</p>

<pre><code>publications {
    // jar publication -- this will be executed last
    mainJar(MavenPublication) {
        from components.java
        [
                [jarTask : sourceJar,  classifier : 'sources', extension : 'jar'],
                [jarTask : javadocJar, classifier : 'javadoc', extension : 'jar']
        ].each {archive -&gt;
            artifact (archive.jarTask) {
                classifier = archive.classifier
                extension  = archive.extension
            }
        }
        pom.withXml {
            Node node = asNode()
            node.children().last() + {
                resolveStrategy = Closure.DELEGATE_FIRST
                packaging 'jar'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/license/LICENSE-2.0.txt'
                        distribution 'repo'
                    }
                }
            }
            if (!project.ext.pomFile.exists()) {
                writeTo(project.ext.pomFile)
            }
        }
    }
    // publication of jar signatures
    jarSignatures(MavenPublication) {
        getSignatureFiles().each {signature -&gt;
            artifact (signature.archive) {
                classifier = signature.classifier
                extension  = signature.extension
            }
        }
    }
    // publication of pom signatures depends on existence of pom file.
    if (project.ext.pomFile.exists()) {
        'gpg-pom'(MavenPublication) {
            artifact (getPomSignature()) {
                classifier = null
                extension  = 'pom.asc'
            }
        }
    }
}
repositories {
    maven {
        // siwtch repository location by existence of pom file
        if (project.ext.pomFile.exists()) {
            // target repository
            url "file:/${project.projectDir}/artifacts"
        } else {
            // temporary repository
            url "file:/${project.projectDir}/tmp"
        }
    }
}
</code></pre>

<p>}
```</p>

<p>そして、artifactを発行するために、</p>

<p>次のコマンドを二度発行します。</p>

<p><code>
$ gradle clean pP publish
</code></p>

<p>これで、maven repositoryへ署名ファイル付きのリリースができるようになります。</p>

<p>次回は、今回の記事の要約文を掲載する予定です。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle 1.4以降から追加されているmaven-publishプラグインでは、まだmaven central レポジトリーに上げられないようです。]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/15/publishing-artifact-with-gradles-new-maven-publish-plugin-is-currently-unavailable/"/>
    <updated>2013-06-15T15:53:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/15/publishing-artifact-with-gradles-new-maven-publish-plugin-is-currently-unavailable</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/forum-assets/images/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>あ、また、例によって記事が長いので、</p>

<p>結論だけ見たい人は前半部分だけを見て下さい。 &ndash; 大体5分以内。</p>

<p>で、gradleでのmaven centralへのライブラリー登録方法を知りたい方は中盤部分まで読んで下さい。 &ndash; トータル15分。</p>

<p>で、僕の強引なgradle遊びまで読みたい方は最後まで読むといいかもしれません。 &ndash; トータル30分。</p>

<hr />

<p><strong>前半部分</strong></p>

<p>ここ数日gradle1.4以降についかされた<strong>maven-publish</strong>プラグインを使って</p>

<p>maven centralへのライブラリー登録方法を調べていましたが、</p>

<h1>maven-publishプラグインでのmaven central repoへの登録はまだサポートされてません</h1>

<p>ようです。</p>

<p>元記事はこちらです。</p>

<ul>
<li><a href="http://forums.gradle.org/gradle/topics/how_to_publish_artifacts_signatures_asc_files_using_maven_publish_plugin">How to publish artifacts signatures (.asc files) using maven-publish plugin?</a></li>
</ul>


<p>以下、簡単な意訳＋要約文</p>

<blockquote><h3>質問</h3>

<p>maven-publishプラグインを使ってレポジトリー情報の設定と、それと別個に、singningプラグインを使ってartifactsへのサインを行うことができますが、それらを連携させることができません。</p>

<p>どのようにすればmaven-publishプラグインで、artifactsとサインファイル(.ascファイル)をアップロードするようにできますか？</p>

<h3>回答</h3>

<p>今のところmaven-publishプラグインを使ってartifactとsignatureをアップロードすることはサポートされていません。<strong>Gradle</strong>に「.asc」ファイル(サインしたファイル)が通常のartifactではなく、特別なartifactであることを伝える手段がないことが問題となっています。</p>

<p><a href="https://github.com/gradle/gradle/blob/master/design-docs/publication-model.md">こちらのロードマップ</a>を参照下さい。なお、この機能に関する優先順位は高くありません。</p>

<h3>再質問</h3>

<p>現在、古い方法でのアップロードはサポートされていますか？それとも手作業でやらないと駄目ですか？</p>

<h3>回答</h3>

<p>古い方法でのアップロードは利用できます。</p>

<h3>提案</h3>

<p>ありがとうございました。</p>

<p>ところで、ドキュメントの方で新しいプラグインではmaven centralにアップロード出来ないという記述がないので追加してもらえますか？</p></blockquote>

<p>とのことで、maven-publishプラグインでのmaven central repoへのアップロードはまだ対応されていないようです。これはこれで従来のmavenプラグインよりも便利なので、maven centralへのアップロードも可能になって欲しいとろこです。</p>

<hr />

<p><strong>中盤部分</strong></p>

<p>なお、日本語でも情報は入手出来ますが、念の為にこちらにも記述しておきます。</p>

<h1>現状のgradleを用いたmaven centralへのアップロード方法</h1>

<p>概要は、山本裕介氏のこちらの記事を参照して下さい。</p>

<ul>
<li><a href="http://samuraism.jp/diary/2012/05/03/1336047480000.html">【最新版】Maven Central Repository へのライブラリ登録方法 #maven</a></li>
</ul>


<p>また、gradleでの方法についてはこちらを参照して下さい。</p>

<ul>
<li><a href="http://jedicoder.blogspot.jp/2011/11/automated-gradle-project-deployment-to.html">Automated Gradle project deployment to Sonatype OSS Repository(英語)</a></li>
<li><a href="http://d.hatena.ne.jp/int128/20130409/1365434513">GradleでMaven Central Repositoryに成果物をリリースする(日本語)</a></li>
</ul>


<p>両方の記事に共通していますが、Sonatypeからmaven centralにアップロードする場合は、</p>

<ul>
<li>PGPによる署名の作成</li>
<li>求められた規約の順守</li>
</ul>


<p>が求められます。</p>

<h3>なんでこんな面倒くさいのか？</h3>

<p>maven centralにおいてあるライブラリーの品質や、pomなどの情報がバラバラで、一定の品質を保てなかったからのようです。</p>

<p>詳しくはこちらをお読み下さい(英語)。</p>

<ul>
<li><a href="http://www.sonatype.com/people/2010/01/nexus-oss-ecosystem/">Improve The Central Repository and the Supporting the Maven Ecosystem</a></li>
</ul>


<p>central repositoryの品質向上のためにmaven central repoでは下記の規約を儲けています。</p>

<h3>pom.xmlへの要求事項</h3>

<ul>
<li><code>&lt;modelVersion&gt;</code> &ndash; <code>4.0.0</code>を設定する</li>
<li><code>&lt;groupId&gt;</code> &ndash; 申請するときにもgroupIdの申請が必要です。Sonatypeに申請するときはベースになるドメイン名で申請する必要があります。例えば、「<code>org.mikeneck</code>」は大丈夫ですが、「<code>mikeneck</code>」という<strong>groupId</strong>では駄目です。</li>
<li><code>&lt;artifactId&gt;</code> &ndash; ライブラリーの名前ですね。</li>
<li><code>&lt;version&gt;</code> &ndash; バージョン番号です。なお、<code>1.0.0-SNAPSHOT</code>というような<code>SNAPSHOT</code>というバージョンはSonatypeではmaven central repoには乗せてくれませんの、注意して下さい。</li>
<li><code>&lt;packaging&gt;</code> &ndash; 基本的には<code>jar</code>です。</li>
<li><code>&lt;name&gt;</code> &ndash; プロジェクトの名前です。</li>
<li><code>&lt;description&gt;</code> &ndash; ライブラリーに関する情報です。何をしてくれるライブラリーであるかを記述します。</li>
<li><code>&lt;url&gt;</code> &ndash; プロジェクトのurlを設定します。</li>
<li><code>&lt;licenses&gt;</code> &ndash; ライセンスに関する情報を設定します。中には下記の情報が一つ以上入っていることが求められます。</li>
<li><code>&lt;license&gt;&lt;name&gt;</code> &ndash; ライセンス名(ApacheライセンスとかLGPLとか)</li>
<li><code>&lt;license&gt;&lt;url&gt;</code> &ndash; ライセンス条項のurlを記述します</li>
<li><code>&lt;license&gt;&lt;distribution&gt;</code> &ndash; <code>repo</code>を設定します。</li>
<li><code>&lt;scm&gt;&lt;url&gt;</code> &ndash; レポジトリーのurlを記述します。git-hubの場合はsshのアドレス設定します。bitbucketのMercurialの場合はレポジトリーをWebで見る場合のurlを記述します。</li>
<li><code>&lt;scm&gt;&lt;connection&gt;</code> &ndash; git-hubであればsshのところで得られるurlの先頭に<code>scm:git:</code>を加えます。bitbucketのMercurialの場合はWebで見る場合のアドレスの先頭に<code>scm:hg:</code>を付与します。</li>
<li><code>&lt;developers&gt;</code> &ndash; 開発者情報を記入します。その中の構成は次のとおりです。</li>
<li><code>&lt;developer&gt;&lt;id&gt;</code> &ndash; 開発者のID。通名とかでも良いようです。僕の場合は<code>mike_neck</code>を記入します。</li>
<li><code>&lt;developer&gt;&lt;name&gt;</code> &ndash; 開発者の名前です。僕の場合は<code>Shinya Mochida</code>になります。</li>
<li><code>&lt;developer&gt;&lt;email&gt;</code> &ndash; 開発者のメールアドレスです。僕の場合は<code>mike &lt;at&gt; mikeneck.org</code>としています。</li>
</ul>


<h3>配布するファイルへの規約</h3>

<ul>
<li><code>&lt;packaging&gt;</code>が<code>jar</code>の場合にはjarファイルにはjavaクラスが入っていること</li>
<li>名前が<code>projectname-version-javadoc.jar</code>というjavadocのjarが入っていること</li>
<li>名前が<code>projectname-version-sources.jar</code>というソースのjarが入っていること</li>
<li>すべてのartifact(<code>pom.xml</code>、<code>projectname-version.jar</code>、<code>projectname-version-javadoc.jar</code>、<code>projectname-version-sources.jar</code>)に対してPGPによる署名がなされていること</li>
<li>公開鍵が公開鍵サーバーから取得可能になっていること</li>
</ul>


<p>となっています。</p>

<p>また、何らかの理由でjavadocのjarやsourcesのjarが作られない場合でも、READMEというファイルを含んだjavadocのjarよsourcesのjarを作る必要があります。</p>

<h3>gradleでmaven centralにアップロードするためのbuild.gradle</h3>

<p>では、サンプルのbuild.gradleをここに上げておきます。</p>

<p>```groovy build.gradle
[&lsquo;groovy&rsquo;, &lsquo;signing&rsquo;, &lsquo;maven&rsquo;, &lsquo;idea&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// project information
sourceCompatibility = jdkVersion
targetCompatibility = jdkVersion
group = &lsquo;org.jojo.sample&rsquo;
version = &lsquo;1.0&rsquo;
// dependency management
repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}
dependencies {</p>

<pre><code>compile 'org.codehaus.groovy:groovy-all:2.1.3'
testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
</code></pre>

<p>}
// compile options
tasks.withType(Compile) {</p>

<pre><code>options.encoding = 'UTF-8'
</code></pre>

<p>}
// javadoc settings (making template locale en_US)
javadoc {</p>

<pre><code>options.locale = 'en_US'
</code></pre>

<p>}
// creating jars
task sourcesJar (type : Jar) {</p>

<pre><code>classifier = 'sources'
from sourceSets.main.allSource
</code></pre>

<p>}
task javadocJar (type : Jar, dependsOn : javadoc) {</p>

<pre><code>classifier = 'javadoc'
from javadoc.destinationDir
</code></pre>

<p>}
// collect artifacts to be signed
artifacts {</p>

<pre><code>archives jar
archives sourceJar
archives javadocJar
</code></pre>

<p>}
// sign artifacts
signing {</p>

<pre><code>sign configurations.archives
</code></pre>

<p>}
// uploading artifacts
uploadArchives {</p>

<pre><code>repositories.mavenDeployer {
    beforeDeployment {MavenDeployment deployment -&gt;
        signPom(deployment)
    }
    repository (url : sonatypeUrl) {
        authentication (
                userName : sonatypeUsername,
                password : sonatypePassword)
    }
    pom.project {
        name project.name
        packaging 'jar'
        description 'sample project'
        url projectUrl
        licenses {
            license {
                name 'The Apache Software License, Version 2.0'
                url 'http://www.apache.org/license/LICENSE-2.0.txt'
                distribution 'repo'
            }
        }
        scm {
            url githubUrl
            connection "scm:git:${githubUrl}"
            developerConnection "scm:git:${githubUrl}"
        }
        developers {
            developer {
                id 'jojo'
                name 'Jonathan Joester'
                email 'mike &lt;at&gt; mikeneck.org'
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>また、よく使いまわす変数については<code>gradle.properties</code>に書いておきます。</p>

<p><code>bash gradle.properties
jdkVersion=1.7
projectUrl=https://github.com/mike-neck/mike-neck.github.com
github=git@github.com:mike-neck/mike-neck.github.com.git
</code></p>

<p>また、署名関連の変数などについては<code>~/.gradle/gradle.properties</code>に書いておきます。</p>

<p>```bash gradle.properties</p>

<h1>siging information</h1>

<p>signing.keyId=ABCD1234
signing.password=HOGEpassword00
signing.secretKeyRingFile=/Users/username/.gnupg/secring.gpg</p>

<h1>sonatype information</h1>

<p>sonatypeUrl=<a href="https://oss.sonatype.org/service/local/staging/deploy/maven2/">https://oss.sonatype.org/service/local/staging/deploy/maven2/</a>
sonatypeUsername=username
sonatypePassword=password
```</p>

<p>あとは、<code>gradle</code>コマンドで<code>uploadArchives</code>を記述すれば、</p>

<p>Sonatypeの方にアップロードされます。</p>

<p><code>
$ gradle uploadArchives
</code></p>

<p>なお、事前にSonatypeでの<a href="http://goo.gl/XXfRl">JIRAでissueを登録しておくこと</a>や、</p>

<p><a href="http://goo.gl/w9Exz">Nexus UIで最終的なステージング操作</a>をする必要があります。</p>

<p>参考までに、僕が以前作ったissueのリンクを張っておきます。</p>

<p><a href="https://issues.sonatype.org/browse/OSSRH-4119">OSSRH-4119 request for creating repository for Graffiti-mike</a></p>

<p><a href="https://googledrive.com/host/0B4hhdHWLP7RRN0diTW1CSGptaHM"><img src="http://mike-neck.github.io//googledrive.com/host/0B4hhdHWLP7RRN0diTW1CSGptaHM" style="width : 520px;"/></a></p>

<p>中盤終わり</p>

<hr />

<h3>gradleであそぶコーナー</h3>

<p><strong>TBD</strong>と書きたいのですが…</p>

<p>上記の古いgradleでのアーカイブアップロードの方法は、</p>

<p>やや難点があります。</p>

<p>```</p>

<h2>$ gradle tasks</h2>

<h2>All tasks runnable from root project</h2>

<h2>Build tasks</h2>

<p>assemble &ndash; Assembles the outputs of this project.
build &ndash; Assembles and tests this project.
buildDependents &ndash; Assembles and tests this project and all projects that depend on it.
buildNeeded &ndash; Assembles and tests this project and all projects it depends on.
clean &ndash; Deletes the build directory.
jar &ndash; Assembles a jar archive containing the main classes.</p>

<h2>Documentation tasks</h2>

<p>groovydoc &ndash; Generates Groovydoc API documentation for the main source code.
javadoc &ndash; Generates Javadoc API documentation for the main source code.</p>

<h2>Help tasks</h2>

<p>dependencies &ndash; Displays all dependencies declared in root project &lsquo;properties-builder&rsquo;.
dependencyInsight &ndash; Displays the insight into a specific dependency in root project &lsquo;properties-builder&rsquo;.
help &ndash; Displays a help message
projects &ndash; Displays the sub-projects of root project &lsquo;properties-builder&rsquo;.
properties &ndash; Displays the properties of root project &lsquo;properties-builder&rsquo;.
tasks &ndash; Displays the tasks runnable from root project &lsquo;properties-builder&rsquo; (some of the displayed tasks may belong to subprojects).</p>

<h2>IDE tasks</h2>

<p>cleanIdea &ndash; Cleans IDEA project files (IML, IPR)
idea &ndash; Generates IDEA project files (IML, IPR, IWS)</p>

<h2>Upload tasks</h2>

<p>uploadArchives &ndash; Uploads all artifacts belonging to configuration &lsquo;:archives&rsquo;</p>

<h2>Verification tasks</h2>

<p>check &ndash; Runs all checks.
test &ndash; Runs the unit tests.</p>

<h2>Other tasks</h2>

<p>cleanIdeaWorkspace
install &ndash; Installs the &lsquo;archives&rsquo; artifacts into the local Maven repository.
wrapper</p>

<h2>Rules</h2>

<p>Pattern: build<ConfigurationName>: Assembles the artifacts of a configuration.
Pattern: upload<ConfigurationName>: Assembles and uploads the artifacts belonging to a configuration.
Pattern: clean<TaskName>: Cleans the output files of a task.</p>

<p>To see all tasks and more detail, run with &mdash;all.</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 10.478 secs
```</p>

<p>uploadArchivesのところを見ると、</p>

<p><code>archives</code> configurationに登録されているすべてのartifactsをアップロードする</p>

<p>と書かれています。</p>

<p>ただ、これだと、ひとつのアップロードしか書いていくことができないので、</p>

<p>非常に面倒です。</p>

<p>たとえば、こういった局面があります。</p>

<ul>
<li>in-houseリポジトリーにも登録する</li>
<li>maven centralにも登録する</li>
<li>異なるartifactsをアップロードする</li>
<li>dependenciesにトリッキーなことをしているので、dependenciesの記述を書き換えたい</li>
</ul>


<p>こういったケースでは、</p>

<p>一つ一つ別々のタスクとして記述をしていかないとできない場合があります。</p>

<p>gradleは柔軟性も求めるツールなので、</p>

<p>これらの要望も吸収して</p>

<p>簡単な記述でできるように常に進化を遂げています。</p>

<p>それを満たす機能が、今回のテーマの<strong>maven-publish</strong>プラグインです。</p>

<p><strong>maven-publish</strong>プラグインでは<code>archives</code> configuration以外の成果物も</p>

<p>柔軟に発行できますし、依存性を書き換えることもできます。</p>

<p>記述はこんな感じになります。</p>

<p>```groovy build.gradle
[&lsquo;groovy&rsquo;, &lsquo;maven-publish&rsquo;].each {</p>

<pre><code>apply plugin : it
</code></pre>

<p>}
// 中略
publishing {</p>

<pre><code>publications {
    ourMavenServer(MavenPublication) {
        from components.java
        artifact sourceJar
        pom.withXml {
            def node = asNode()
            node.removeNode(node.dependencies[0])
            asNode().children().last() + {
                resolveStrategy = CLosure.DELEGATE_FIRST
                // writing additional pom elements with builder style
                name 'our-subproject'
                description 'our-subproject description'
                url 'https://www.google.com'
            }
            // overwrite dependencies
            asNode().dependencies[0].replaceNode {
                resolveStrategy = Closure.DELEGATE_FIRST
                dependencies {
                    def dep = project.configurations.another.dependencies
                    dep.each {d -&gt;
                        dependency {
                            groupId d.group
                            artifactId d.name
                            version d.version
                            scope 'compile'
                        }
                    }
                }
            }
        }
    }
}
repositories {
    maven {
        name 'in-house'
        url 'https://repos.mycompany.com/nexus/service/local/staging/deploy/maven2/'
    }
}
</code></pre>

<p>}
```</p>

<p>上記の例でやっていることは</p>

<ul>
<li>ドキュメント読まないのでclassesとsourcesだけをアーカイブ化</li>
<li>ちろっとpom.xmlに情報を追加</li>
<li>dependenciesを書き換え</li>
</ul>


<p>一般常識的に考えれば、dependenciesの書き換えはマズイと思われますが…</p>

<p>某有名なライブラリーのpom.xmlでありもしないartifactを参照しているライブラリーがあり、</p>

<p><code>compile</code> configurationではプロジェクトのdependencyを指定するのではなく、</p>

<p>```
configurations {</p>

<pre><code>another
</code></pre>

<p>}
```</p>

<p>と異なるconfigurationを設定して、</p>

<p>プロジェクトのdependencyを設定する場合などがあります。</p>

<p>某有名ライブラリーとは<strong>org.eclipse.jetty:jetty-server</strong>というんですけどね…</p>

<hr />

<p>さて、もう少し遊んでいるんですが、</p>

<p>それは別の記事にしますね。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradleのjavadocタスクでjavadocを英語で出力する方法]]></title>
    <link href="http://mike-neck.github.io/blog/2013/06/13/how-to-generate-javadoc-in-english-on-japanese-environment/"/>
    <updated>2013-06-13T22:39:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/06/13/how-to-generate-javadoc-in-english-on-japanese-environment</id>
    <content type="html"><![CDATA[<p><img src="http://www.gradle.org/img/gradle_logo.gif"/></p>

<p>こんにちわ、みけです。</p>

<p>表題の件はこの記事の前半部分に書いています。</p>

<p>なので、必要な人は前半部分だけ読んで下さい。</p>

<hr />

<p>大した話ではありませんが、</p>

<h1>gradleのjavadocタスクで出力されるjavadocが日本語で出力される</h1>

<p>のがちょっと残念な時があります。</p>

<p><code>java</code>プラグインを入れていれば、<code>javadoc</code>タスクが自動で追加されます。</p>

<p>僕のような日本語環境でやっている人だと、</p>

<p>頑張ってjavadocを英語で書いても、</p>

<p>テンプレートが日本語で出力されてしまいます。</p>

<p>会社で日本語を使っていて、</p>

<p>javadocが日本語でないと困る場合は、</p>

<p>全然問題ないとおもいますが…</p>

<p>オープンソースなソフトウェアを開発している場合、</p>

<p>javadocが日本語だとなんか若干困ります。</p>

<p>(まあ、だいたいjavadocのテンプレートなんで、何が出力されているかなんてわかりますけどね…)</p>

<h1><code>javadoc</code>タスクの設定で<code>options.locale</code>に<code>en_US</code>を指定すればいいです</h1>

<p>つまり、以下のとおりになります。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;</p>

<p>javadoc {</p>

<pre><code>options.locale = 'en_US'
</code></pre>

<p>}
```</p>

<p><strong>本題、終わり</strong></p>

<hr />

<p>ちなみに、僕の得意技はtypoなので、間違えてこんなビルドスクリプト書いてました。</p>

<p><strong>(誤)</strong></p>

<p>```groovy build.gradle
apply plugin : &lsquo;java&rsquo;</p>

<p>javadoc {</p>

<pre><code>options.local = 'en_US'
</code></pre>

<p>}
```</p>

<p>これを実行したら、こんなエラーが出力されました。</p>

<p>```
$ gradle javadoc
Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8</p>

<p>FAILURE: Build failed with an exception.</p>

<ul>
<li><p>Where:
Script &lsquo;/Users/mike/myprojects/sample/build.gradle&rsquo; line: 4</p></li>
<li><p>What went wrong:
A problem occurred evaluating script.</p>

<blockquote><p>No such property: local for class: org.gradle.external.javadoc.StandardJavadocDocletOptions
Possible solutions: locale</p></blockquote></li>
<li><p>Try:
Run with &mdash;stacktrace option to get the stack trace. Run with &mdash;info or &mdash;debug option to get more log output.</p></li>
</ul>


<p>BUILD FAILED</p>

<p>Total time: 8.941 secs
```</p>

<p>gradle曰く</p>

<blockquote><p><code>local</code>なんてオプションないよ、<code>locale</code>じゃない？</p></blockquote>

<p>というわけで、</p>

<h1>gradleさん正しい答えを教えてくれたりと、親切ですね。</h1>

<p>本当に親切なツールです。</p>

<p>しかし、</p>

<h1>本当に親切なのはgroovyの思想</h1>

<p>です。</p>

<p>例えば次のようなgroovyのスクリプトがあるとします。</p>

<p>```groovy error.groovy
def range = 1..10
range.colect {</p>

<pre><code>println (it * it)
</code></pre>

<p>}
```</p>

<p>これを実行するとこういうエラーが出力されます。</p>

<p>```
$ groovy error.groovy
Caught: groovy.lang.MissingMethodException: No signature of method: groovy.lang.IntRange.colect() is applicable for argument types: (error$<em>run_closure1) values: [error$</em>run_closure1@639d564]
Possible solutions: collect(), collect(), collect(groovy.lang.Closure), collect(groovy.lang.Closure), collect(java.util.Collection, groovy.lang.Closure), collect(java.util.Collection, groovy.lang.Closure)
groovy.lang.MissingMethodException: No signature of method: groovy.lang.IntRange.colect() is applicable for argument types: (error$<em>run_closure1) values: [error$</em>run_closure1@639d564]
Possible solutions: collect(), collect(), collect(groovy.lang.Closure), collect(groovy.lang.Closure), collect(java.util.Collection, groovy.lang.Closure), collect(java.util.Collection, groovy.lang.Closure)</p>

<pre><code>at error.run(error.groovy:2)
</code></pre>

<p>```</p>

<p>存在しないメソッドを呼び出した時に、</p>

<p><strong>Possible solutions</strong>ということで、</p>

<p>サジェストしてくれます。</p>

<p>また、有名な例ですが、Power Assertもあります。</p>

<p><code>groovy error.groovy
def list = [1,1,2,3,4,5]
assert list - [1,3,6] == [1,2,4,5]
</code></p>

<p>これを実行すると、このように表示されます。</p>

<p>```
$ groovy error.groovy
Caught: Assertion failed:</p>

<p>assert list &ndash; [1,3,6] == [1,2,4,5]</p>

<pre><code>   |    |         |
   |    [2, 4, 5] false
   [1, 1, 2, 3, 4, 5]
</code></pre>

<p>Assertion failed:</p>

<p>assert list &ndash; [1,3,6] == [1,2,4,5]</p>

<pre><code>   |    |         |
   |    [2, 4, 5] false
   [1, 1, 2, 3, 4, 5]

at error.run(error.groovy:2)
</code></pre>

<p>```</p>

<p>ただ、求めている結果と実際の結果が<strong>違う</strong>という表示だけでなく、</p>

<p>実際の値を示してくれます。</p>

<p>つまり一言で言えば、</p>

<h1>groovyの半分は優しさでできています</h1>

<p>なお、この機能はもともとからgroovyにあったわけではなく、</p>

<p>Spockというテスティングフレームワークから採用された機能です。</p>

<p>groovyの思想では、こういった、(・∀・)ｲｲﾈ!!な機能を</p>

<p>どんどん取り込んでいくというのがあると思っています。</p>

<p>まあ、元々、javaを良い感じで書きたいといった思想から生まれている言語ですし、</p>

<p>実際に、rubyなど他の言語のいいところを借りたりしているので、</p>

<p>後発の優位性を遺憾なく発揮しているわけですが…</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradleとJUnitのEnclosedの話]]></title>
    <link href="http://mike-neck.github.io/blog/2013/05/25/an-falseding-xian-nihamatutetaren-gaitagradletojunitfalseenclosedfalsehua/"/>
    <updated>2013-05-25T23:19:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/05/25/an-falseding-xian-nihamatutetaren-gaitagradletojunitfalseenclosedfalsehua</id>
    <content type="html"><![CDATA[<p>みけです。</p>

<p><a href="http://mike-neck.github.io/blog/2013/05/25/javadehazimetesocketpuroguramuwoshu-itemita/">先ほど書いたエントリー</a>でテストをgradleで走らせたのですが、</p>

<blockquote class="twitter-tweet" lang="ja"><p>gradleでテストした時に謎のclassMethodとかいうテストが勝手に挟み込まれて、落ちて困っている</p>&mdash; もちださんさん (@mike_neck) <a href="https://twitter.com/mike_neck/status/338275875294441472">2013年5月25日</a></blockquote>


<script async src="http://mike-neck.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>という状態が発生してました。</p>

<p>具体的には、</p>

<p>```java
package org.mikeneck.multithreads;</p>

<p>import org.junit.*;
import org.junit.experimental.runners.Enclosed;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;</p>

<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;</p>

<p>import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;</p>

<p>/<em>*
 * @author mike
 </em>/
@RunWith(Enclosed.class)
public class SimpleSocketTest {</p>

<pre><code>public static class SingleClient {

    private static final ExecutorService SERVICE = Executors.newFixedThreadPool(1);

    private static final int PORT = 12521;

    private static final String LOCALHOST = "localhost";

    private SimpleClient client;

    @Rule
    public TestName testName = new TestName();

    @BeforeClass
    public static void start () throws IOException {
        SERVICE.execute(new SimpleServer(PORT));
    }

    @Before
    public void setup () throws IOException {
        client = new SimpleClient(LOCALHOST, PORT);
    }

    @After
    public void tearDown () throws Exception {
        System.out.println(testName.getMethodName() + " is closing");
        client.close();
    }

    @AfterClass
    public static void end () throws IOException {
        new SimpleClient(LOCALHOST, PORT).open().bye();
    }

    @Test
    public void socketProcessing () throws IOException {
        client.open();
        String message = client.sendMessage("Hello");
        System.out.println("Message from Server [" + message + "]");
        assertThat(message, is("Hello"));
        System.out.println("Assertion ends.");
    }
}
</code></pre>

<p>}
```</p>

<p>というテストに対して、</p>

<p><img src="https://googledrive.com/host/0B4hhdHWLP7RRaS15VXNZRTNVWUU" style="width : 424px; height : 262px;" /></p>

<p>という感じで、謎の<code>classMethod</code>というテストが追加されていて、</p>

<p>実行されてテストが落ちてしまうようです。</p>

<h2>先駆者はいた</h2>

<p>とりあえず、<code>gradle</code>、<code>Enclosed</code>、<code>Junit</code>でググっていたところ、</p>

<p>次の二つのエントリーを発見しました。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/irof/20120430/p1">GradleでEnclosedのテストが二回実行されるんだ</a></li>
<li><a href="http://d.hatena.ne.jp/shuji_w6e/20120808/1344386399">GradleでEnclosedテストが2回実行されることの対策</a></li>
</ul>


<p>というわけで、<code>gradle</code>と<code>Enclosed</code>の相性がわるいっぽい…</p>

<h2>gradleでEnclosedなテストをする時の対策</h2>

<p>というわけで、<a href="https://twitter.com/shuji_w6e">@shuji_w6e</a>さんのページによると</p>

<p><strong>テストの実行時に除外クラスを指定すること。</strong></p>

<p>だそうです。</p>

<p>```groovy build.gradle
apply plugin : &lsquo;groovy&rsquo;
apply plugin : &lsquo;idea&rsquo;</p>

<p>group = &lsquo;org.mikeneck.multithreads&rsquo;
version = &lsquo;1.0&rsquo;</p>

<p>def compatibility = 1.7</p>

<p>sourceCompatibility = compatibility
targetCompatibility = compatibility</p>

<p>repositories {</p>

<pre><code>mavenCentral ()
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile 'org.codehaus.groovy:groovy-all:2.1.3'
testCompile ('junit:junit:4.11') {
    exclude module : 'hamcrest-core'
    exclude module : 'hamcrest'
}
testCompile 'org.hamcrest:hamcrest-library:1.+'
</code></pre>

<p>}</p>

<p>test {</p>

<pre><code>exclude '**/*$*'
</code></pre>

<p>}
```</p>

<p>とりあえず、テストクラスを除外してみました。</p>

<h2>結果</h2>

<p><img src="https://googledrive.com/host/0B4hhdHWLP7RRczBZcy04U2tNMms" style="width : 424px; height : 252px;"" /></p>

<p>という感じで、テストが通りました。</p>

<p><!-- admax -->
<script type="text/javascript" src="http://adm.shinobi.jp/s/d0f95faac716337846b3bcf82925c26e"></script>
<!-- admax -->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40855644-1', 'github.io');
  ga('send', 'pageview');

</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gradle1.6からgroovyのconfigurationはdeprecatedになっています]]></title>
    <link href="http://mike-neck.github.io/blog/2013/05/22/gradle1-dot-6karagroovyfalseconfigurationhadeprecatedninatuteimasu/"/>
    <updated>2013-05-22T20:08:00+09:00</updated>
    <id>http://mike-neck.github.io/blog/2013/05/22/gradle1-dot-6karagroovyfalseconfigurationhadeprecatedninatuteimasu</id>
    <content type="html"><![CDATA[<h2>gradle1.6からgroovyのconfigurationは非推奨になっています</h2>

<p>まあ今さらですが、さきほどbuild.gradleを書いた時に、</p>

<p>```
$ gradle idea
The groovy configuration has been deprecated and is scheduled to be removed in Gradle 2.0. Typically, usages of &lsquo;groovy&rsquo; can simply be replaced with &lsquo;compile&rsquo;. In some cases, it may be necessary to additionally configure the &lsquo;groovyClasspath&rsquo; property of GroovyCompile and Groovydoc tasks.
:ideaModule
Download <a href="http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3.pom">http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3.pom</a>
Download <a href="http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3-sources.jar">http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3-sources.jar</a>
Download <a href="http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3.jar">http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.3/groovy-all-2.1.3.jar</a>
:ideaProject
:ideaWorkspace
:idea</p>

<p>BUILD SUCCESSFUL</p>

<p>Total time: 11.174 secs
$
```</p>

<p>と表示されたので、「うぉっ」と思ってドキュメントを読んでみました。</p>

<p><a href="http://www.gradle.org/docs/current/release-notes#groovy-configuration-is-deprecated">groovy configuration is deprecated</a></p>

<p>じゃあ、今後どうするのかというと、</p>

<h1>compile configurationにgroovyのartifactを指定する</h1>

<p>ということです。</p>

<p>つまり、これまでは</p>

<p>```groovy build.gradle
dependencies {</p>

<pre><code>groovy : 'org.codehaus:groovy:groovy-all:2.1.3'
</code></pre>

<p>}
```</p>

<p>と書いていましたが、</p>

<p>```groovy build.gradle
dependencies {</p>

<pre><code>compile : 'org.codehaus.groovy:groovy-all:2.1.3'
</code></pre>

<p>}
```</p>

<p>と書けばよいようです。</p>

<table>
<tbody>
<tr>
<td><iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kkkjkrt-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=B009X5KIFK" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
</td>
<td><iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kkkjkrt-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=3864900492" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
</td>
<td><iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=kkkjkrt-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=1617291307" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
</td>
</tr>
</tbody>
</table>



]]></content>
  </entry>
  
</feed>
